# 异常与多线程

## 异常

- 异常：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。
- 在Java等面向对象的编程语言中，异常本身就是一个类，产生异常就是创建异常对象并抛出一个异常对象；**Java处理异常的方式是中断处理**。

- 异常体系：

  异常的根类是`java.lang.Throwable`，包含两个子类：`java.lang.Error`和`java.lang.Exception`。

- ==异常分类==：

  - `java.lang.Throwable`：是Java语言中所有错误或异常的超类。
    - `Exception`：编译器异常，进行编译(写代码)java程序出现的问题。
      - `RuntimeException`：运行期异常，Java程序运行过程中出现的问题。
    - `Error`：错误。必须修改源代码，程序才能继续执行。
      - `OutOfMemoryError`：内存溢出的错误。

- ==Java异常处理的五个关键字：**try、catch、finally、throw、throws**==

-  **`throw`关键字**

  - 作用：使用`throw`关键字在指定的方法中抛出指定的异常。

  - 使用格式：

    `throw new xxxException("异常产生的原因");`

  - 【注意】
    1. `throw`关键字必须写在方法的内部。

    2. `throw`关键字后边`new`的对象必须是`Exception`或者`Exception`的子类对象。

    3. `throw`关键字抛出指定的异常对象，我们必须处理这个异常对象。

       - `throw`关键字后边创建的是`RuntimeException`或者是`RuntimeException`的子类对象，即**运行期异常**，可以不处理，默认交给JVM处理（打印异常对象，中断程序）。

         `NullPointerException`是一个运行期异常。    

       - `throw`关键字后边创建的是**编译异常**（写代码的时候报错），我们就必须处理这个异常，要么`throws`，要么`try…catch`。

         `FileNotFoundException`是一种编译异常。

- **`Objects`非空判断**

  - `public static <T> T requireNonNull(T obj)`：查看指定的引用对象是不是`null`。

  - 源码：

    ```java
    public static <T> T requireNonNull(T obj){
    	if(obj==null){
    		throw new NullpointerException();
    	}
    	retturn obj;
    }
    ```

- **声明异常的`throws`关键字**

  - `throws`关键字：<u>异常处理的第一种方式，交给别人处理</u>。
  - 作用：
    - 当方法内部抛出异常对象的时候，我们就必须处理这个异常对象。
    - 可以使用`throws`关键字处理异常对象，会把异常对象声明抛出给方法的调用者处理（自己不处理，交给别人处理），最终交给JVM处理-->中断处理。

  - 使用格式：在方法声明的时候使用

    ```java
    修饰符 返回值类型 方法名(参数列表) throws AAAException,BBBException···{
    	throw new AAAException("产生原因");
        throw new BBBException("产生原因");
    }
    ```

  - 【注意】
    1. `throws`关键字必须写在方法声明处。
    2. `throws`关键字后边声明的异常必须是`Exception`或者是`Exception`的子类。
    3. 方法内部如果抛出了多个异常对象，那么`throws`后边必须也声明多个异常；如果抛出的多个异常对象有子父类关系，那么直接声明符类异常即可。
    4. 调用了一个声明抛出异常的方法，我们就必须处理声明的异常，要么继续使用`throws`声明抛出，交给方法的调用者处理，最终交给JVM处理，要么`try···catch`自己处理异常。

- **`try···catch`异常处理**

  - `try···catch`：<u>异常处理的第二种方法，自己处理异常</u>。

  - 格式：

    ```java
    try{
    	可能产生异常的代码
    }catch(定义一个异常的变量，用来接收try中抛出的异常对象){
        异常的处理逻辑，异常之后，如何处理异常对象；一般会把异常的信息记录到一个日志中
    }
    ···//可以有多个catch
    catch(异常类名 变量名){
        
    }
    ```

  - 【注意】
    1. `try`中可能会抛出多个异常对象，那么就需要使用多个`catch`来处理这些异常对象。
    2. 如果`try`中产生了异常，那么就会执行`catch`中的异常处理逻辑，执行完毕，再继续执行`try···catch`之后的代码；如果`try`中没有产生异常，那么就不会执行`catch`中的异常处理逻辑，直接执行`try···catch`之后的代码。

  -  `Throwable`类中定义了3个异常处理的方法。
    1. `String getMessage()`：返回此`throwable`的简短描述。
    2. `String toString()`：返回此`throwable`的详细消息字符串。
    3. `void printStackTrace()`：JVM打印异常对象，默认此方法，打印的异常信息是最全面的。

- **`finally`代码块**

  - 格式：

    ```java
    try{
    	可能产生异常的代码
    }catch(定义一个异常的变量，用来接收try中抛出的异常对象){
        异常的处理逻辑，异常之后，如何处理异常对象；一般会把异常的信息记录到一个日志中
    }
    ···//可以有多个catch
    catch(异常类名 变量名){
        
    }finally{
    	无论是否出现异常都会执行
    }
    ```

  - 【注意】
    1. `finally`不能单独使用，必须和`try`一起使用。
    2. `finally`一般用于资源释放（资源回收），无论程序是否出现异常，最后都要释放资源（IO）。

- 异常的【注意事项】

  - 多个异常使用捕获时的处理方法：

    1. 多个异常分别处理。

    2. 多个异常一次捕获，多次处理。

       一个`try`多个`catch`的情况：`catch`里边定义的异常变量，如果存在父子类关系，那么子类的异常变量必须写在前边，否咋就会报错。

    3. 多个异常一次捕获一次处理。

  - 如果`finalli`有`return`语句，永远返回的是`finally`中的结果，避免该情况。
  - 子父类的异常：
    1. 如果父类抛出异常，子类重写父类方法的时候，抛出和父类相同的异常或者抛出父类异常的子类或者不抛出异常。
    2. 父类方法没有抛出异常，子类重写父类该方法时，也不能抛出异常。此时，子类产生的异常，只能捕获处理，不能够声明抛出。

- 自定义异常类

  - 格式：

    ```java
    public class xxxException extends Exception/RuntimeException{
    	添加一个空参数的构造方法
        添加一个带异常信息的构造方法
    }
    ```

  - 【注意】
    1. 自定义异常类一般都是以`Exception`结尾，说明该类是一个异常类。
    2. 自定义异常类，必须的继承`Exception`或者`RuntimeException`。
       - 继承`Exception`：那么自定义的异常类就是一个编译器异常，如果方法内部抛出了编译器异常，就必须处理这个异常，要么`throws`，要么`try···catch`。
       - 继承`RuntimeException`：那么自定义的异常类就是一个运行期异常，无需处理，交给JVM处理。

##  线程实现方式

- 一些概念知识：

  - 并发与并行

    - 并发（交替执行）：指两个或多个事件在同一个时间段内发生。

    - 并行（同时执行）：指两个或多个事件在同一个时刻发生（同时发生）。

  - 线程与进程：

    - 进程：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。
    - 线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中也可以有多个线程。

  - 线程调度：

    - 分时调度

      所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间。

    - 抢占式调度

      优先让优先级高的线程使用CPU，如果线程的优先级相同，那么随机选择一个，**Java使用的是抢占式调度**。

  - **主线程**：执行主（main）方法的线程。

- **创建多线程**

  - 创建多线程程序的【**第一种方式**】：创建`Thread`类的子类。

    ​	`java.lang.Thread`类：是描述线程的类，想要实现多线程程序，必须继承`Thread`类。

    - 实现步骤：
      1. 创建一个`Thread`类的子类。
      2. 在`Thread`类的子类中重写`Thread`类中的`run`方法，设置线程任务（开启线程要做什么）。
      3. 创建`Thread`类的子类对象。
      4. 调用`Thread`类中的**`start`方法**，开启新的线程，执行`run`方法。

  - 创建多线程程序的【**第二种方式**】：实现`Runnable`接口。

    ​	`java.lang.Runnable`接口：

    ​			`Runnable` 接口应该由那些打算通过某一线程执行其实例的类来实现。类必须定义一个称为 `run`  的无参数方法。

    ​	`java.lang.Thread`类的构造方法：

    ​			`Thread(Runnable target)`：分配新的`Thread`对现象。

    ​			`Thread(Runnable target,String name)`：分配新的`Thread`对象。

    - 实现步骤：
      1. 创建一个`Runnable`接口的实现类。
      2. 在实现类中重写`Runnable`接口的`run`方法，设置线程任务。
      3. 创建一个`Runnable`接口的实现类对象。
      4. 创建`Thread`类对象，构造方法中传递`Runnable`接口的实现类对象。
      5. 调用`Thread`类中的`start`方法，开启新的线程执行`run`方法。

    - 实现`Runnable`接口创建多线程程序的【优点】：

      1. 避免了单继承的局限性。

         - 一个类只能继承一个类，类继承了`Thread`类就不能继承其他的类；

           实现了`Runnable`接口，还可以继承其他的类，实现其他的接口。

      2. 增强了程序的扩展性，降低了程序的耦合性（解耦）。

         - 实现`Runnable`接口的方式，把设置线程任务和开启新线程进行分离（解耦）；

           实现类中，重写了`run`方法：用来设置线程任务；

           创建`Thread`类对象，调用`start`方法：用来开启新线程。

  - 匿名内部类方式实现线程的创建：

    - 匿名内部类：即写在其他类内部的没有名字的类。
    - 作用：简化代码
      - 把子类继承父类，重写父类的方法，创建子类对象合成一步完成。
      - 把实现类实现接口，重写接口中的方法，创建实现类对象合成一步完成。

    - 匿名内部类的最终产物：子类/实现类对象，而这个类没有名字。

    - 格式：

      ```java
      new 父类/接口(){
          重写父类/接口中的方法。
      }
      ```

- `Thread`类【常用方法】：

  - 获取线程的名称：

    1. 使用`Thread`类中的方法`getname()`

       `String getName()`返回该线程的名称。

    2. 可以先获取到当前正在执行的线程，使用线程中的方法`getName()`获取线程的名称

       `static Thread currentThread()` 返回对当前正在执行的线程对象的引用。
  
  - 设置线程的名称：
  
    1. 使用`Thread`类中的方法`setname(名字)`
  
       `void setName(String name)`：改变线程名称，使之与参数name相同。
  
    2. 创建一个带有参数的构造方法，参数传递线程的名称；调用父类的带参构造方法，把线程名称传递给父类，让父类（Thread）给子线程起一个名字。
  
       `Thread(String name)`：分配新的Thread对象。
  
  - `public static void sleep(long millis)`：使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。

## 线程同步机制

- 为了保证每个线程都能正常执行原子操作，解决线程安全问题，Java引入了线程同步机制。有3种方式完成同步操作：
  1. ==同步代码块。==
  2. ==同步方法。==
  3. ==锁机制。==

- **【1】同步代码块**：

  - `synchronized`关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。

  - 格式：

    ```java
    synchronized(锁对象){
        可能会出现线程安全问题的代码(访问了共享数据的代码)
    }
    ```

  - 【注意】
    1. 通过代码块中的锁对象，可以使用任意的对象。
    2. 但是必须保证多个线程使用的锁对象是同一个。
    3. 锁对象的作用：把同步代码块锁住，只让一个线程在同步代码块中执行。

- **【2】同步方法**：

  - 使用步骤：
    1. 把访问了共享数据的代码抽取出来，放到一个方法中。
    2. 在方法上添加`synchronized`修饰符。

  - 格式：定义方法的格式

    ```java
    修饰符 synchronized 返回值类型 方法名(参数列表){
    	可能会出现线程安全问题的代码(访问了共享数据的代码)
    }
    ```

  - **同步方法的锁对象是实现类对象，即`this`。**

    静态同步方法的锁对象不是`this`，因为`this`是创建对象之后产生的，而静态方法优先于对象。因此，**静态同步方法的锁对象是本类的`class`属性**-->`class`文件对象（反射）。

- **【3】Lock锁**

  - `java.util.concurrent.locks.Lock`接口

    `Lock`实现提供了比使用`synchronized`方法和语句可获得的更广泛的锁定操作。

    `Lock`接口中的方法：

    ​		`void lock()`：获取锁。

    ​		`void unlock()`：释放锁。

  - 使用步骤：
    1. 在成员位置创建一个`ReentrantLock`对象。
    2. 在可能出现安全问题的代码前调用`Lock`接口中的方法`lock`获取锁。
    3. 在可能出现安全问题的代码后调用`Lock`接口中的方法`unlock`释放锁。

## 等待唤醒机制

- 线程状态（6种状态）

  ![image-20200724185144047](C:\Users\shanshan\AppData\Roaming\Typora\typora-user-images\image-20200724185144047.png)

  1. Timed Waiting（计时等待）
  2. Blocked（锁阻塞）：一个正在阻塞等待一个监视器锁（锁对象）的线程处于这一状态。
  3. Waiting（无限等待）：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。

- `Object`类中的`wait`带参方法和`notifyAll`方法
  - 进入到TimeWaiting（计时等待）有两种方式：
    1. 使用`sleep(long m)`方法，在毫秒值结束之后，线程睡醒进入到`Runnable/Blocked`状态。
    2. 使用`wait(long m)`方法，`wait`方法如果在毫秒值结束之后，还没有被`notify`唤醒，就会自动醒来，线程睡醒进入到`Runnable/Blocked`状态。

  - 唤醒的方法：
    1. `notify()`：如果多个线程等待，随机唤醒一个。
    2. `notifyAll()`：唤醒所有等待的线程。

- 等待唤醒机制
  - 【注意】
    1. `wait`方法与`notify`方法必须要由同一个锁对象调用。
    2. `wait`方法与`notify`方法是属于`Object`类的方法的。
    3. `wait`方法与`notify`方法必须在同步代码块或者是同步函数中使用。

- 生产者与消费者问题

## 线程池

- 线程池：就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多的资源。

- 合理利用线程池的【优点】
  1. 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程可以被重复利用，可执行多个任务。
  2. 提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行。
  3. 提高线程的可管理性。

- 线程池的实现

  - `java.util.concurrent.Executors`：线程池的工厂，用来生成线程池。

    - `Executors`类中的静态方法：

      `static ExecutorService newFixedThreadPool(int nThreads)`创建一个可重用固定线程数的线程池。

      参数：

      ​		`int nThreas`：创建线程池中包含的线程数量。

      返回值：

      ​		`ExecutorService`接口，返回的是`ExecutorService`接口的实现类对象。

    `java.util.concurrent.ExecutorService`：线程池接口