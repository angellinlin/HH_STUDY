# 异常与多线程

## 异常

- 异常：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。
- 在Java等面向对象的编程语言中，异常本身就是一个类，产生异常就是创建异常对象并抛出一个异常对象；**Java处理异常的方式是中断处理**。

- 异常体系：

  异常的根类是`java.lang.Throwable`，包含两个子类：`java.lang.Error`和`java.lang.Exception`。

- ==异常分类==：

  - `java.lang.Throwable`：是Java语言中所有错误或异常的超类。
    - `Exception`：编译器异常，进行编译(写代码)java程序出现的问题。
      - `RuntimeException`：运行期异常，Java程序运行过程中出现的问题。
    - `Error`：错误。必须修改源代码，程序才能继续执行。
      - `OutOfMemoryError`：内存溢出的错误。

- ==Java异常处理的五个关键字：**try、catch、finally、throw、throws**==

-  **`throw`关键字**

  - 作用：使用`throw`关键字在指定的方法中抛出指定的异常。

  - 使用格式：

    `throw new xxxException("异常产生的原因");`

  - 【注意】
    1. `throw`关键字必须写在方法的内部。

    2. `throw`关键字后边`new`的对象必须是`Exception`或者`Exception`的子类对象。

    3. `throw`关键字抛出指定的异常对象，我们必须处理这个异常对象。

       - `throw`关键字后边创建的是`RuntimeException`或者是`RuntimeException`的子类对象，即**运行期异常**，可以不处理，默认交给JVM处理（打印异常对象，中断程序）。

         `NullPointerException`是一个运行期异常。    

       - `throw`关键字后边创建的是**编译异常**（写代码的时候报错），我们就必须处理这个异常，要么`throws`，要么`try…catch`。

         `FileNotFoundException`是一种编译异常。

- **`Objects`非空判断**

  - `public static <T> T requireNonNull(T obj)`：查看指定的引用对象是不是`null`。

  - 源码：

    ```java
    public static <T> T requireNonNull(T obj){
    	if(obj==null){
    		throw new NullpointerException();
    	}
    	retturn obj;
    }
    ```

- **声明异常的`throws`关键字**

  - `throws`关键字：<u>异常处理的第一种方式，交给别人处理</u>。
  - 作用：
    - 当方法内部抛出异常对象的时候，我们就必须处理这个异常对象。
    - 可以使用`throws`关键字处理异常对象，会把异常对象声明抛出给方法的调用者处理（自己不处理，交给别人处理），最终交给JVM处理-->中断处理。

  - 使用格式：在方法声明的时候使用

    ```java
    修饰符 返回值类型 方法名(参数列表) throws AAAException,BBBException···{
    	throw new AAAException("产生原因");
        throw new BBBException("产生原因");
    }
    ```

  - 【注意】
    1. `throws`关键字必须写在方法声明处。
    2. `throws`关键字后边声明的异常必须是`Exception`或者是`Exception`的子类。
    3. 方法内部如果抛出了多个异常对象，那么`throws`后边必须也声明多个异常；如果抛出的多个异常对象有子父类关系，那么直接声明符类异常即可。
    4. 调用了一个声明抛出异常的方法，我们就必须处理声明的异常，要么继续使用`throws`声明抛出，交给方法的调用者处理，最终交给JVM处理，要么`try···catch`自己处理异常。

- **`try···catch`异常处理**

  - `try···catch`：<u>异常处理的第二种方法，自己处理异常</u>。

  - 格式：

    ```java
    try{
    	可能产生异常的代码
    }catch(定义一个异常的变量，用来接收try中抛出的异常对象){
        异常的处理逻辑，异常之后，如何处理异常对象；一般会把异常的信息记录到一个日志中
    }
    ···//可以有多个catch
    catch(异常类名 变量名){
        
    }
    ```

  - 【注意】
    1. `try`中可能会抛出多个异常对象，那么就需要使用多个`catch`来处理这些异常对象。
    2. 如果`try`中产生了异常，那么就会执行`catch`中的异常处理逻辑，执行完毕，再继续执行`try···catch`之后的代码；如果`try`中没有产生异常，那么就不会执行`catch`中的异常处理逻辑，直接执行`try···catch`之后的代码。

  -  `Throwable`类中定义了3个异常处理的方法。
    1. `String getMessage()`：返回此`throwable`的简短描述。
    2. `String toString()`：返回此`throwable`的详细消息字符串。
    3. `void printStackTrace()`：JVM打印异常对象，默认此方法，打印的异常信息是最全面的。

- **`finally`代码块**

  - 格式：

    ```java
    try{
    	可能产生异常的代码
    }catch(定义一个异常的变量，用来接收try中抛出的异常对象){
        异常的处理逻辑，异常之后，如何处理异常对象；一般会把异常的信息记录到一个日志中
    }
    ···//可以有多个catch
    catch(异常类名 变量名){
        
    }finally{
    	无论是否出现异常都会执行
    }
    ```

  - 【注意】
    1. `finally`不能单独使用，必须和`try`一起使用。
    2. `finally`一般用于资源释放（资源回收），无论程序是否出现异常，最后都要释放资源（IO）。

- 异常的【注意事项】

  - 多个异常使用捕获时的处理方法：

    1. 多个异常分别处理。

    2. 多个异常一次捕获，多次处理。

       一个`try`多个`catch`的情况：`catch`里边定义的异常变量，如果存在父子类关系，那么子类的异常变量必须写在前边，否咋就会报错。

    3. 多个异常一次捕获一次处理。

  - 如果`finalli`有`return`语句，永远返回的是`finally`中的结果，避免该情况。
  - 子父类的异常：
    1. 如果父类抛出异常，子类重写父类方法的时候，抛出和父类相同的异常或者抛出父类异常的子类或者不抛出异常。
    2. 父类方法没有抛出异常，子类重写父类该方法时，也不能抛出异常。此时，子类产生的异常，只能捕获处理，不能够声明抛出。

- 自定义异常类

  - 格式：

    ```java
    public class xxxException extends Exception/RuntimeException{
    	添加一个空参数的构造方法
        添加一个带异常信息的构造方法
    }
    ```

  - 【注意】
    1. 自定义异常类一般都是以`Exception`结尾，说明该类是一个异常类。
    2. 自定义异常类，必须的继承`Exception`或者`RuntimeException`。
       - 继承`Exception`：那么自定义的异常类就是一个编译器异常，如果方法内部抛出了编译器异常，就必须处理这个异常，要么`throws`，要么`try···catch`。
       - 继承`RuntimeException`：那么自定义的异常类就是一个运行期异常，无需处理，交给JVM处理。

##  线程实现方式

- 一些概念知识：

  - 并发与并行

    - 并发（交替执行）：指两个或多个事件在同一个时间段内发生。

    - 并行（同时执行）：指两个或多个事件在同一个时刻发生（同时发生）。

  - 线程与进程：

    - 进程：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。
    - 线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中也可以有多个线程。

  - 线程调度：

    - 分时调度

      所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间。

    - 抢占式调度

      优先让优先级高的线程使用CPU，如果线程的优先级相同，那么随机选择一个，**Java使用的是抢占式调度**。

  - **主线程**：执行主（main）方法的线程。

- **创建多线程**

  - 创建多线程程序的【**第一种方式**】：创建`Thread`类的子类。

    `java.lang.Thread类`：是描述线程的类，想要实现多线程程序，必须继承`Thread`类。

    - 实现步骤：
      1. 创建一个`Thread`类的子类。
      2. 在`Thread`类的子类中重写`Thread`类中的`run`方法，设置线程任务（开启线程要做什么）。
      3. 创建`Thread`类的子类对象。
      4. 调用`Thread`类中的**`start`方法**，开启新的线程，执行`run`方法。

  - 多线程的原理

- `Thread`类常用方法：

  - 获取线程的名称：

    1. 使用`Thread`类中的方法`getname()`

       `String getName()`返回该线程的名称。

    2. 可以先获取到当前正在执行的线程，使用线程中的方法`getName()`获取线程的名称

       `static Thread currentThread()` 返回对当前正在执行的线程对象的引用。



