- ## next()和nextLine()的区别

  - next（）一定要读取到有效字符后才可以结束输入，在有效字符前遇到空格、tab或enter等结束符，next（）会自动将其去掉，只有在输入有效字符之后，next（）方法才将其后输入的空格、tab或enter等视为分割符或结束符。**所以next（）不能得到带空格的字符串，nextLine()遇到回车才是结束，所以可以得到带空格的字符串**
  - 在输入一个int类型的数字之后，如果后边采用nextLine的话，最后打印结果发现会少一个字符，原因是**在你使用nextInt的时候后边有一个换行符，没有接受，前边的int变量只是接受了你输入的数值**，所以在你继续输入nextLine之后，**会自动读取还未读取的换行**，所以会导致后边的结果有一列为空，所以需要多输入一个NextLine把未接受的换行符接收到。
  
- ## equals()和equalsIgnoreCase()的区别

  对字符串的**内容**比较，可以使用两个方法：

  - `public boolean equals(Object obj)`:参数可以是任何对象，只有参数是一个字符串并且内容相同的才会给true，否则返回false

    注意事项：1.任何对象都能用Object进行接收

    ​					2.equals方法具有对称性，也就是a.equals(b)和b.equals(a)效果一样。

    ​					3.如果比较双方一个常量一个变量，推荐把常量字符串写在前面。

    ​					推荐：“abc”.equals(str)  不推荐：str.equals("abc") 

    ​					当str为null时前能正常运行，后者会报错空指针异常

  - `public boolean equalsIgnoreCase(String str):`忽略大小写，进行内容比较

- ## ArrayList和LinkedList的区别

  - 1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。（LinkedList是双向链表，有next也有previous）

    2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。

    3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。

  - 各自优缺点：

    1.对于ArrayList和LinkedList而言，在列表末尾增加一个元素所花的开销都是固定的。对于ArrayList而言，主要是在内部数组中增加一项，指向所添加的元素，偶尔可能会导致对数组重新进行分配；而对LinkedList而言，这个开销是统一的，分配一个内部Entry对象

    2.在ArrayList的中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；而在LinkedList的中间插入或删除一个元素的开销是固定的。

    3.LinkedList不支持高效的随机元素访问

    4.ArrayList的空间浪费主要体现在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间

  

