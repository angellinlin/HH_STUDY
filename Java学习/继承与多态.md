- ## 继承

  - **继承是多态的前提，如果没有继承就没有多态**

    继承主要解决的问题就是：**共性抽取**

    ![image-20200716151519441](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200716151519441.png)

  - **继承关系当中的特点**：

    1.子类可以拥有父类的内容

    2.子类还可以拥有自己专有的内容

  1. #### 继承的格式

     - 在继承的关系中，“子类就是一个父类”。也就是，子类可以被当做父类看待。例如父类是员工，子类是讲师，那么“讲师就是一个员工”。关系：is-a

     - 定义父类的格式：（一个普通的类定义）

       ```
       public class 父类名称{
       	//...
       }
       ```

     - 定义子类的格式：

       ```
       public class 子类名称 extends 父类名称{
       	//...
       }
       ```

  2. #### 继承中成员变量的访问特点

     在父类的继承关系当中，如果成员变量重名，则创建子类对象时，有两种访问方式：

     - 直接通过子类对象访问成员变量：

       ​		等号左边是谁，就优先用谁，没有则向上找（这里等号是指new对象时的对象）

     - 间接通过成员方法访问成员变量：

       ​		该方法属于谁，就优先用谁，没有则向上找

  3. #### 区别子类方法中重名的三种写法

     局部变量：						直接写成员变量名

     本类的成员变量：			 this.成员变量名

     父类的成员变量：			 super.成员变量名

  4. #### 重名成员方法的访问规则

     - 在父子类的继承关系当中，创建子类对象，访问成员方法的**规则**：

     ​			创建的对象是谁，就优先用谁，如果没有则向上找

     - **注意事项：**无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类的。

  5. #### 方法的覆盖重写（Override）

     - 重写概念：在继承关系当中方法名一样，参数列表也一样

     - **重写和重载的区别**

       重写（Override）：方法的名称一样，参数列表【也一样】。也可以叫做覆盖、覆写

       重载（Overload）：方法的名称一样，参数列表【不一样】

     - 方法的覆盖重写**特点**：创建的是子类对象，则优先用子类方法

     - **注意事项：**

       1.必须保证父子类之间方法的名称相同，参数列表也相同

       ​	`@Override`：写在方法前面，用来检验是不是有效的正确覆盖重写。（是注解，不是注释）

       ​	这个注解就算不写，只要满足要求，也是正确的方法覆盖重写

       2.子类方法的**返回值**必须【**小于等于**】父类方法的**返回值范围**

       ​	**小扩展**`java.lang.Object`类是所有类的公共最高父类（祖宗类），`java.lang.String`就是`Object`的子类

       3.子类方法的**权限**必须【**大于等于**】父类方法的**权限**修饰符

       ​	**小扩展：**public>proteced>(default)>private

       ​	**备注：**（default）不是关键字，是表示什么都没写，留空

     - **应用tips：**

       对于已经投入使用的类，尽量不要进行修改。推荐定义一个新的类，来重复利用其中共性内容，并且添加改动新内容

  6. #### 构造方法的访问特点

     - 子类构造方法中有一个默认隐含的“`super（）`”调用，所以一定是先调用的父类构造，后执行的子类构造
     - 子类构造可以通过`super`关键字来调用父类重载构造
     - `super`的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造

     **总结：**子类必须调用父类构造方法，不写则赠送`super（）`，写了则用写的指定的super调用，super只能有一个，还必须是第一个。

  7. #### super关键字的用法（访问父类）

     - 在子类成员方法中，访问父类的成员变量
     - 在子类成员方法中，访问父类的成员方法
     - 在子类的构造方法中，访问父类的构造方法

  8. #### this关键字的用法（访问子类）

     - 在本类的成员方法中，访问本类的成员变量

     - 在本类的成员方法中，访问另一个成员方法

     - 在本类的构造方法中，访问本类的另一个构造方法。

       **注意:**

       ​	1.`this(...)`调用也必须是构造方法的第一个语句，唯一一个

       ​	2.super和this两种构造调用，不能同时使用。

  9. #### Java继承的三个特点

     - Java是**单继承**的：一个类的直接只能有唯一一个
     - Java语言可以**多级继承**：就是有爷爷
     - 一个子类的直接父亲是唯一的，但是一个父类可以拥有很多个子类。可以有兄弟姐妹

- ## 抽象（抽象方法和抽象类）

  - 如果父类当中的方法不确定如何进行{}方法体实现，那么这就应该是一个**抽象方法**

  1. #### 书写格式

     **抽象方法：**就是加上`abstract`关键字，然后去掉大括号，直接分号结束

     **抽象类：**抽象方法所在的类，必须是抽象类才行。在class之前写上`abstract`即可

     ```
     public abstract class Animal{
     	public abstract void eat();
     }
     ```

  2. #### 使用注意事项

     - 抽象类**不能创建对象**，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象

     - 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。

       子类的构造方法中，有默认的super（），需要访问父类的构造方法。

     - 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类

     - 抽象类的子类，必须重写抽象父类中**所有的**抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类（alt+enter可以快速重写抽象方法）

  3. #### 发红包实例

     - **题目**：

       群主发普通红包。某群有多名成员，群主给成员发普通红包。普通红包的规则：

       1. 群主的一笔金额，从群主余额中扣除，平均分成n等份，让成员领取
       2. 成员领取红包后，保存到成员余额中。

       根据描述，完成案例中所有类的定义以及指定类之间的继承关系，并完成发红包操作。

     - **分析：**

       1. 类与继承关系

          ![image-20200718154843861](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200718154843861.png)

       2. **发红包**和**收红包**的逻辑

          ![image-20200718154932405](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200718154932405.png)

- ## 接口

  - 接口就是一种**公共的规范标准**，只要符合规范标准，就可以大家**通用**
  - 接口就是多个类的公共规范。接口是一种引用数据类型，最重要的内容就是其中的：**抽象方法**

  1. #### 定义接口的格式：

     ```java
     public interface 接口名称{
     	//接口内容
     }
     ```

     **备注：**

     - 换成关键字interface之后，编译生成的字节码文件仍然是：.java-->.class

     - 如果是Java7，那么接口中可以包含的内容有：1.常量	2.抽象方法

       如果是Java8，那么还可以额外包含有：3.默认方法	4.静态方法

       如果是Java9，那么还可以额外包含有:5.私有方法

  2. #### 接口的抽象方法定义：

     - 在任何版本的java中，接口都能定义抽象方法

     - **格式：**

       ```java
       public abstract 返回值类型 方法名称（参数列表）;
       ```

     - **注意事项：**

       1. 接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract
       2. 这两个关键字修饰符，可以选择性地忽略。（熟练后）
       3. 方法的三要素，可以随意定义

  3. #### 接口的抽象方法使用

     - 接口不能直接使用，必须有一个“实现类”来“实现”该接口

       **格式：**

       ```java
       public class 实现类名称 implements 接口名称{
       	//....
       }
       ```

     - 接口的实现类（最好后面接上Impl）必须覆盖重写（实现）接口中所有的抽象方法

       实现：去掉abstract关键字，加上方法体大括号

     - 创建实现类的对象，进行使用

     - **注意事项：**如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类

  4. #### 默认方法

     - 从java8开始，接口里允许定义默认方法，**来解决接口升级的问题**

     - **格式：**

       ```
       public default 返回值类型 方法名称（参数列表）{
       	方法体
       }
       ```

     - **使用：**

       1. 接口的默认方法，可以通过接口实现类对象，直接调用
       2. 接口的默认方法，也可以被接口实现类进行覆盖重写

  5. #### 静态方法

     - 从java8开始，接口中允许定义静态方法

     - **格式：**

       ```java
       public static 返回值类型 方法名称（参数列表）{
       	方法体
       }
       ```

       提示：就是将abstract或者default换成static即可，带上方法体

     - **使用：**

       通过接口名称，直接调用其中的静态方法

       **格式：**接口名称.静态方法名（参数）

       **注意事项：**不能通过接口实现类的对象来调用接口当中的静态方法（多个实现类之间会发生冲突）

  6. #### 私有方法

     - **问题描述：**我们需要抽取一个共有方法，用来解决两个默认方法之间重复代码的问题。但是这个共用方法不应该让实现类使用，应该是私有化的

       **解决方案：**从java9开始，接口当中允许定义私有方法

       1. 普通私有方法：解决多个**默认方法**之间重复代码的问题

          ```java
          public 返回值类型 方法名称（参数列表）{
          	方法体
          }
          ```

       2. 静态私有方法：解决多个**静态方法**之间重复代码的问题

          ```java
          private static 返回值类型 方法名称（参数列表）{
          	方法体
          }
          ```

  7. #### 常量定义和使用

     - 接口中定义“成员变量”，必须使用`public static final`三个关键字修饰。效果上，就是接口的【常量】

     - **格式：**

       ```
       public static final 数据类型 常量名称 = 数据值;
       ```

       **备注：**一旦使用final关键字进行修饰，说明不可改变

     - **注意事项：**

       1. 接口当中的常量，可以省略`public static final`，**注意**：不写也是照样默认是这样
       2. 接口当中的常量，必须进行赋值，不能不赋值
       3. 接口中常量的名称，使用完全大写的字母，用下划线进行分割（shift+F6）

  8. #### 接口内容小结

     1. **成员变量其实是常量**，格式：

        ```
        [public] [static] [final] 数据类型 常量名称 = 数据值;
        ```

        **注意：**常量必须进行赋值，而且一旦赋值不能改变。常量名称完全大写，用下划线进行分隔。

     2. **接口中最重要的就是抽象方法**，格式：

        ```
        [public] [abstract] 返回值类型 方法名称（参数列表）;
        ```

        **注意**：实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类

     3. **从Java8开始，接口里允许定义默认方法**，格式：

        ```
        [public] default 返回值类型 方法名称（参数列表）{
        	方法体
        }
        ```

        **注意**：默认方法也可以被覆盖重写

     4. **从Java8开始，接口里允许定义静态方法**，格式：

        ```
        [public] static 返回值类型 方法名称(参数列表){
        	方法体
        }
        ```

        **注意：**应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法

     5. **从Java9开始，接口里允许定义私有方法**，格式：

        ```
        普通私有方法：private 返回值类型 方法名称(参数列表){方法体}
        静态私有方法：private static 返回值类型 方法名称(参数列表){方法体}
        ```

        **注意：**private的方法只有接口自己才能调用，不能被实现类或别人使用

  9. #### 接口使用总结及注意事项

     1. 接口是没有静态代码块或者构造方法的

     2. 一个类的直接父类是唯一的，但是一个类可以同时实现多个接口

        格式：

        ```
        public class MyInterfaceImpl implements MyInterfaceA,MyInterfaceB{
        	//覆盖重写所有抽象方法
        }
        ```

     3. 如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可

     4. 如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类

     5. 如果实现类所实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。

     6. 一个类如果直接父类当中的方法，和接口当中的默认方法产生类冲突，优先用父类当中的方法

  10. #### 接口之间的多继承

      - 类与类之间是单继承的，直接父类只有一个
      - 类与接口之间是多实现的，一个类可以实现多个接口
      - 接口与接口之间是多继承
      - **注意事项：**
        1. 多个父接口当中的抽象方法如果重复，没关系
        2. 多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，【而且带着default关键字】

- ## 多态（Multi）

  - `extends`继承或者`implements`实现，是**多态性**的前提.

  - 代码当中体现多态性，其实就是一句话：**父类引用指向子类对象**

    **格式：**

    ```
    父类名称 对象名 = new 子类名称(); //左侧父类的引用，指向了右侧子类的对象，子类对父类函数重载，则遵循”new的是谁就用谁“原则
    或者
    接口名称 对象名 = new 实现类名称();
    ```

  - #### 成员变量的使用特点

    1.直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找

    2.间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找

    ```
    Fu obj = new Zi();
    
    //子类没有覆盖重写，就是父
    //子类如果覆盖重写了，就是子
    obj.showNum();
    ```

  - #### 成员方法的使用特点

    在多态的代码当中，成员方法的访问规则是：

    ​		**看new的是谁，就优先用谁，没有则向上找**

    **口诀：编译看左边，运行看右边**

  - #### 对比成员变量和成员方法

    成员变量：编译看左边，运行还看左边

    成员方法：编译看右边，运行还看右边

  - #### 使用多态的好处

    ![image-20200721101551056](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200721101551056.png)

  - #### 对象的向上转型（其实就是多态写法）

    **格式：**父类名称 对象名 = new 子类名称();

    **含义：**右侧创建一个子类对象，把他当做父类来看待使用

    **注意事项：向上转型一定是安全的。**从小范围转向了大范围。（可以理解为类似于强制类型转换）

    ```
    例子： Animal animal =  new Cat();
    
    含义：创建了一只猫，当做动物看待，没问题。从小范围的猫，向上转换成为更大范围的动物
    ```

    - **弊端：**对象一旦向上转型为父类，那么就无法调用子类原本特有的内容

      **解决方案：**用对象的向下转型【**还原**】。

  - #### 对象的向下转型（其实是一个【还原】动作）

    **格式：**子类名称 对象名 = (子类名称) 父类对象;

    **含义：**将父类对象，【还原】成为本来的子类对象。

    ```
    Animal animal = new Cat();//本来是猫，向上转型成为动物
    Cat cat = (Cat) animal;//本来是猫，已经被当做动物了，还原回来成为本来的猫
    ```

    - **注意事项**
      1. 必须保证对象本来创建的时候，就是猫，才能向下转型成为猫
      2. 如果对象创建的时候本来不是猫，现在非要向下转型成为猫，就会**报错**（ClassCastException）

  - #### instanceof关键字（知道父类引用的对象本来是什么子类）

    ```
    对象 instanceof 类名称
    ```

    **这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例**

    ![image-20200721114256408](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200721114256408.png)

- ## 接口多态的综合实例

  1. #### 笔记本电脑

     ​	笔记本电脑（laptop）通常具备使用USB设备的功能。在生产时，笔记本都预留了可以插入USB设备的USB接口，但具体是什么USB设备，笔记本厂商并不关心，只要符合USB规格的设备都可以。

     ​	定义USB接口，具备最基本的开启功能和关闭功能。鼠标和键盘要想能在电脑上使用，那么鼠标和键盘也必须遵守USB规范，实现USB接口，否则鼠标和键盘的生产出来也无法使用

  2. #### 案例分析

     进行描述笔记本类，实现笔记本使用的USB鼠标、USB键盘

     - USB接口，包含打开设备功能、关闭设备功能
     - 笔记本类，包含开机功能、关机功能、使用USB设备功能
     - 鼠标类，要实现USB接口，并具备点击的方法
     - 键盘类，要实现USB接口，具备敲击的方法!

     ![image-20200721122527588](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200721122527588.png)
  
- ## final关键字

  1. final关键字代表**最终、不可改变的**
     - 对于**基本类型**来说，不可变说的是变量当中的**数据**不可改变
     - 对于引用类型来说，不可变说的是变量当中的**地址值**不可改变
  2. 常见四种用法：
     - 可以用来修饰一个类
     - 可以用来修饰一个方法
     - 还可以用来修饰一个局部变量
     - 还可以用来修饰一个成员变量

  - #### 用于修饰类

    ```
    public final class 类名称{
    	//...
    }
    ```

    **含义：**当前这个类**不能有任何子类**（太监类）

    **注意：**一个类如果是final的，那么其中所有的成员方法都无法进行覆盖重写（因为没儿子）

  - #### 用于修饰方法

    当final关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是**不能被覆盖重写**

    ```
    修饰符 final 返回值类型 方法名称（参数列表）{
    	//方法体
    }
    ```

  - #### 修饰局部变量

    一旦使用final用来修饰局部变量，那么这个变量就不能进行更改。

    **“一次赋值，终生不变”**

    - 对于**基本类型**来说，不可变说的是变量当中的**数据**不可改变
    - 对于引用类型来说，不可变说的是变量当中的**地址值**不可改变

    ![image-20200722143248570](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200722143248570.png)

  - #### 修饰成员变量

    1. 由于成员变量具有默认值，所以用了1final之后必须手动赋值，不会再给默认值了
    2. 对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。二者选其一
    3. 必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值

- ## 权限修饰符

  ​								public   	 >  		protected		>		(default)		>		private

  同一个类					√								√								√								√

  同一个包					√								√								√								×

  不同包子类				√								√								×							    ×

  不同包非子类			√								×								×								×

  - **定义一个类的时候，权限修饰符规则：**
    1. 外部类：public/（default）
    2. 成员内部类：四种都可
    3. 局部内部类：什么都不写（但是和（default）含义不同，只能在方法中使用）

- ## 内部类

  - #### 概念与分类

    1. 如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类，被包含的那个类称作**内部类**。如：身体和心脏的关系

    2. **分类：**

       成员内部类

       局部内部类（包含匿名内部类）

  - #### 成员内部类

    ```
    修饰符 class 外部类名称{
    	修饰符 class 内部类名称{
    		//....
    	}
    	//...
    }
    ```

    **注意：内用外，随意访问；外用内，需要内部类对象**

    创建一个内部类的前提是要先有一个外部类

    - **两种使用方式：**

      1. **间接方式**：在外部类的方法当中，使用内部类；然后main只是调用外部类的方法

         ![image-20200722150815909](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200722150815909.png)

         ![image-20200722150835366](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200722150835366.png)

      2. **直接方式：外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();**

    - **同名变量访问**

      ```
      内部类访问外部类的重名变量，格式：
      外部类名称.this.外部类成员变量名
      ```

      ![](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200722151709173.png)

  - #### 局部内部类（定义在方法内部）

    ”局部“：只有当前所属的方法才能使用它，出了这个方法外面就不能用了

    ```
    修饰符 class 外部类名称{
    	修饰符 返回值类型 外部类方法名称（参数列表）{
    		class 局部内部类名称{
    			//...
    		}
    	}
    }
    ```

    - **局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】**

      备注：从java8+开始，只要局部变量事实不变，那么final关键字可以省略

      **原因：**

      1. new出来的对象在堆内存中
      2. 局部变量是跟着方法走的，在栈内存当中
      3. 方法运行结束之后，立刻出栈，局部变量就会立刻消失
      4. 但是new出来的对象会在堆当中持续存在，直到垃圾回收消失

  - #### 匿名内部类（属于局部内部类）【重要！！】

    如果接口的实现类（或者是父类的子类）只需要使用唯一的一次。那么这种情况下就可以省略掉该类的定义，而改为使用【**匿名内部类**】

    ```
    接口名称 对象名 = new 接口名称(){
    	//覆盖重写所有抽象方法
    };
    ```

    - 对格式”new 接口名称(){...}“进行解析：

      1. new代表创建对象的动作
      2. 接口名称就是匿名内部类需要实现哪个接口
      3. {...}这才是匿名内部类的内容

    - **注意事项**

      1. 匿名内部类，在【创建对象】的时候，只能使用唯一一次

         如果希望多次创建对象，而且类的内容一样的话，那么就必须使用单独定义的实现类了

      2. 匿名对象，在【调用方法】的时候，只能调用唯一一次

         如果希望同一个对象，调用多次方法，那么必须给对象起名字

      3. 匿名内部类是省略了【实现类/子类名称】，但是匿名对象是省略了【对象名称】

      4. **匿名内部类和匿名对象不是一回事！！**
  
- ## 类作为成员变量类型（最常见的是String）

- ## 接口作为成员变量类型

