- ## 集合

  - 集合是java中提供的一种**容器**，可以用来存储多个数据

  - #### 集合和数组的区别

    1. 数组长度是固定的，集合长度可变

    2. 数组存储的是同一类型的元素，可以村粗基本数据类型和对象。

       集合存储的都是对象，而且对象的类型可以不一致。一般对象多时，使用集合进行存储

  - #### 学习集合的目标

    1. 会使用集合存储数据
    2. 会遍历集合，把数据取出来
    3. 掌握每种集合的特性

  - #### 集合框架的学习方法

    1. **学习顶层**:学习顶层接口/抽象类中共性的方法，所有的子类都可以使用
    2. **使用底层**:底层不是接口就是抽象类，无法创建对象使用，需要使用底层的子类创建对象使用

- ## Collection集合

  - #### 集合框架

    ![image-20200727112606975](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200727112606975.png)

    1. **Collection接口**

       - 定义的是所有单列集合中共性的方法
       - 所有的单列结合都可以使用共性的方法
       - **没有带索引的方法**

    2. **List接口**

       - 有序的集合（存储和取出元素顺序相同）
       - 允许存储重复的元素
       - 有索引，可以使用普通的foe循环遍历

    3. **set接口**

       - 不允许存储重复元素

       - 没有索引（**不能使用普通的for循环遍历**）

       - **TreeSet**和**HashSet**集合是**无序**的集合（存储和取出元素的顺序有可能不一致）

         **LinkedHashSet**集合是**有序**的集合

  - #### Collection常用功能

    - `public boolean add（E e）`：把给定的对象添加到当前集合中

      返回值是boolean值，一般都返回true，所以可以不用接收

      ![image-20200727115522725](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200727115522725.png)

    - `public void clear（）`：清空集合中所有的元素。**但不删除集合，集合还存在**

    - `public boolean remove（E e）`：把给定的对象在当前集合中删除

      返回值是一个boolean值，集合中存在元素，删除元素，返回true。集合中不存在的元素，删除失败，返回false

      ![image-20200727115654738](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200727115654738.png)

    - `public boolean contains（E e）`：判断当前集合中是否包含给定的对象

      包含返回true，不包含返回false

      ![image-20200727115738239](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200727115738239.png)

    - `public boolean isEmpty（）`：判断当前集合是否为空

      集合为空返回true，集合不为空返回false

    - `public int size（）`：返回集合中元素的个数

    - `public Object[] toArray（）`：把集合中的元素，存储到数组中

- ## Iterator迭代器（用于遍历）

  - **迭代：**即Collection集合元素的通用获取方式。在取元素之前要先判断集合中有没有元素，如果有，就把这个元素取出来，继续判断，如果还有就再取出来。一直到把集合中的所有元素全部取出，这种取出方式专业术语称为迭代

  - #### 常用的方法

    - `boolean hasNext()：`判断集合中还有没有下一个元素，有就返回true，没有就返回false
    - `E next()：`取出集合中的下一个元素

  - #### 注意

    Iterator迭代器，是一个**接口**，我们无法直接使用，需要使用Iterator接口的实现类对象，获取实现类的方式比较特殊。

    Collection接口中有一个方法，叫Iterator（），这个方法返回的就是迭代器的实现类对象

    `Iterator<E>  iterator() :`返回在此collection的元素上进行迭代的迭代器

  - #### 迭代器的使用步骤【重点】

    1. 使用集合中的方法iterator（）获取迭代器的实现类对象，使用Iterator接口接收（多态）

    2. 使用Iterator接口中的方法hasNext判断还有没有下一个元素

    3. 使用Iterator接口中的方法next取出集合中的下一个元素

       ![image-20200727152326971](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200727152326971.png)

       ![image-20200727152358620](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200727152358620.png)

  - #### 迭代器实现原理

    ![image-20200727152919212](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200727152919212.png)

    ![image-20200727152938912](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200727152938912.png)

- ## 增强for循环

  - 也称为for each循环，专门用来**遍历数组和集合**。他的内部原理其实是个Iterator迭代器，**在遍历过程中，不能对集合中的元素进行增删操作**

  - 所有单列集合都可以使用增强for

  - **格式**

    ```
    for（集合/数组的数据类型 变量名：集合名/数组名）{
    	sout（变量名）;
    }
    ```

    ![image-20200727155122437](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200727155122437.png)

- ## 泛型

  - 是一种未知的数据类型，当我们不知道使用什么数据类型的时候，就可以使用**泛型**

  - 泛型也可以看出来是一个变量，用来接收数据类型

    E	e：Element 元素

    T	t：Type 类型

  - 创建集合对象的时候，就会确定泛型的数据类型

  ![image-20200727161426837](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200727161426837.png)

  - #### **创建集合对象，不使用泛型**

    **好处：**集合不使用泛型，默认的类型就是Object类型，可以存储任意类型的数据

    **弊端：**不安全，会引发异常

    ![image-20200727162055558](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200727162055558.png)

  - #### 创建集合对象，使用泛型

    **好处：**

    1. 避免了类型转换的麻烦，存储的是什么类型，取出的就是什么类型
    2. 把运行期异常（代码运行之后会抛出的异常），提升到了编译期（写代码的时候会报错）

    **弊端：**泛型是什么类型，只能存储什么类型的数据

  - #### 泛型的定义与使用

    - **定义含有泛型的类**（模拟ArrayList集合）

      - 泛型是一个未知的数据类型，当我们不确定什么数据类型的时候，可以使用泛型
      - 泛型可以接受任意的数据类型，可以使用Integer，String，Student....
      - **创建对象的时候确定泛型的数据类型**
      - 不写泛型默认为Object类

    - **定义含有泛型的方法**

      - 泛型定义在方法的修饰符和返回值类型之间

      - 格式：

        修饰符 <泛型> 返回值类型 方法名（参数列表（使用泛型））{

        ​		方法体；

        }

      - 含有泛型的方法，在调用方法的时候确定泛型的数据类型。**传递什么类型的参数，泛型就是什么类型**

    - **定义含有泛型的接口**

      - 第一种使用方式：**定义接口的实现类，实现接口，指定接口的泛型**
      - 第二种使用方式：**接口使用什么泛型，实现类就使用什么泛型，类跟着接口走**。相当于定义了一个含有泛型的类，**创建对象的时候确定泛型的类**。例如List和ArrayList

  - #### 泛型通配符 <?>

    - 当使用泛型类或者接口时,传递的数据中，泛型类型不确定，可以通过通配符<?>表示。**代表任意的数据类型**

    - 与泛型的区别在于：泛型要先定义再使用，通配符本身就存在，可以直接使用

    - **通配符基本使用**

      - **不知道使用什么类型来接收的时候，此时可以使用？，？表示未知通配符**
      - 此时**只能接收**数据，不能往该集合中存储数据
      - 不能创建对象使用，只能作为方法的参数使用
      - 泛型没有继承概念

    - **通配符高级使用---受限泛型**

      - **泛型的上限限定**：代表使用的泛型只能是E类型的子类/本身

        ```java
        类型名称 <？ extends E> 对象名称
        ```

      - **泛型的下限限定**：代表使用的泛型只能是E类型的父类/本身

        ```java
        类型名称 <？ super E> 对象名称
        ```

- ## 集合综合案例--斗地主洗牌+发牌

  1. #### 准备牌

     - 54张牌，存储到一个**集合**中

     - 特殊牌：大王、小王

     - 其他52张牌：

       ​	定义一个数组/集合，存储4种花色：黑桃、红心、花草、方片

       ​	定义一个数组/集合，存储13个序号：2、A、K.....3

     - 循环嵌套遍历两个数组/集合:组装52张牌

  2. #### 洗牌

     ​	使用集合工作类Collection方法：会随机的打乱集合中元素的顺序

     ```java
     static void shuffle(List<?> list)
     ```

  3. #### 发牌

     - **要求**:1人17张牌，剩余3张作为底牌，一人一张轮流发牌。

     - 定义4个集合，存储3个玩家的牌和底牌

     - 集合的索引（0-53）%3

       ​	索引%2，有两个值（0,1） 0%2=0  1%2=1  2%2=0  3%2=1

       ​	索引%3，有三个值（0,1）  0%3=0  1%3=3  2%3=2  3%3=0

       ​	索引>=51 向底牌发牌（注：先判断底牌i>=51）

  4. #### 看牌

     直接打印集合，遍历存储玩家和底牌的集合

- ## 数组

  - **查询快**：数组的地址是连续的，我们通过数组的首地址可以找到数组，通过数组的索引可以快速查找某一个元素

  - **增删慢：**数组的长度是固定的，我们想要增加/删除一个元素，必须创建一个新数组，把源数组的数据复制过来

    **在堆内存中，频繁的创建数组，复制数组中的元素，销毁数组，效率低下**

- ## 链表

  - 一个节点包含一个数据源（存储数组），两个指针域（存储地址：自己地址与下一节点地址）

    ![image-20200806172647799](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200806172647799.png)

  - **单项链表**：链表中只有一条链子，不能保证元素的**顺序（存储元素和取出元素的顺序有可能不一致）**

    **双向链表**：链表中有两条链子，是有序的链子

  - **查询慢**：链表中地址不是连续的，每次查询元素，都必须从头开始查询

    **增删快**：链表结构，增加/删除一个元素，对链表的整体结构没有影响，所以增删快

- ## 红黑树

  - **特点：**趋近于平衡树，查询的速度非常快，查询叶子结点最大次数和最小次数不能超过2倍
  - **约束：**
    1. 节点可以是红色的或者黑色的
    2. 根节点是黑色的
    3. 叶子节点是黑色的
    4. 每个红色的结点的子节点都是黑色的
    5. 任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同

- ## List集合

  - java.util.List接口 extends Collection接口

  - #### 特点

    1. 有序的集合（存取元素顺序一致）
    2. 有索引，包含了一些带索引的方法
    3. 与set不同，允许存储重复的元素

  - #### 带索引的方法（特有）

    - `public void add(int index, E element)`：将指定的元素，添加到该集合中的指定位置上

    - `public E get(int index)`：返回集合中指定位置的元素

    - `public E remove(int index)`：移除列表中指定位置的元素，返回的是被移除的元素

    - `public E set(int index, E element)`：用指定元素替换集合中指定位置的元素，返回的更新前的元素

    - **注意：操作索引的时候，一定要防止索引越界异常**

      IndexOutOfBoundsException:索引越界异常

      ArrayIndexOutOfBoundsException：数组索引越界异常

      StringIndexOutOfBoundsException：字符串索引越界异常

  - #### List集合遍历的三种方式

    ```java
    //1.普通for循环
    for(int i=0;i<list.size();i++){
        //public E get(int index):返回集合中指定位置的元素
        String s = list.get(i);
        System.out.println(s);
    }
    
    //2.使用迭代器
    Iterator<String> it = list.iterator();
    while(it.hasNext()){
        String s = it.next();
        System.out.println(s);
    }
    
    //3.使用增强for
    for(String s : list){
        System.out.println(s);
    }
    ```

  - #### List的子类

    - #### ArrayList集合

      1. ArrayList集合数据存储的结构是**数组**结构。
      2. 元素增删慢，查找快，**多线程的**
      3. 有序日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList是最常用的集合（但粗暴的使用ArrayList来完成任何需求，是不严谨的）

    - #### LinkedList集合

      1. 底层是一个**链表**结构：查询慢，增删快。是多线程的

      2. 里面包含了大量操作收尾元素的方法

         **注意：使用LinkedList集合特有的方法，不能使用多态**

      3. **常用方法**

         ```
         public void addFirst(E e)//将指定元素插入此列表的开头
         public void addLast(E e)//将指定元素添加到此列表的结尾，等效add()
         public void push(E e)//将元素推入次列表所表示的堆栈
         ```

         ```
         public E getFirst()//返回次列表的第一个元素
         public E getLast()//返回此列表的最后一个元素
         ```

         ```
         public E removeFirst()//移除并返回此列表的第一个元素
         public E removeLast()//移除并返回此列表的最后一个元素
         public E pop()//从此列表所表示的堆栈处弹出一个元素
         ```

         ```
         public boolean isEmpty()//如果列表不包含元素，则返回true
         ```

         clear()清空集合中的元素

    - #### Vecter集合

      1. 底层是数组，原理与ArrayList相同，被其取代现在使用很少
      2. 是单线程的

- ## Set集合

  - #### Set接口特点

    1. 不允许存储重复元素
    2. 没有索引，没有带索引的方法，也**不能使用普通的for循环遍历**（遍历时用迭代器/增强for）

  - #### HashSet特点（实现了Set接口）

    1. 不允许存储重复的元素
    2. 没有索引，没有带索引的方法，也**不能使用普通的for循环遍历**（遍历时用迭代器/增强for）
    3. 是一个无序的集合，存储元素和取出元素的顺序有可能不一致
    4. 底层是一个哈希表结构（查询的速度非常快）

  - #### 哈希表结构

    - **哈希值：**是一个十进制的整数，由系统随机给出（就是对象的地址值，是一个**逻辑地址**，是**模拟**出来得到的地址，不是数据实际存储的物理地址）

    - **获取哈希值的方法：hashCode方法**

      `public native int hashCode()`:返回对象的哈希码值

      native:代表该方法调用的是本地操作系统的方法

    - **哈希表**

      - jdk1.8之前：哈希表=数组+链表

        jdk1.8之后：哈希表=数组+链表

        ​					   哈希表=数组+红黑树（提高查询速度）

        ​					   **当链表的长度超过了8位，那么就会把链表转换为红黑树（提高查询的速度）**

      - **哈希表的特点：速度快**

      - **数组结构：把元素进行了分组（相同哈希值的元素是一组）**，初始大小是16

        **链表/红黑树：把相同哈希值的元素连接到一起**

        ![image-20200807220352642](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200807220352642.png)

  - #### Set集合不允许存储重复元素的原理

    - Set集合在调用add方法时，会调用元素的hashCode方法和equals方法，判断元素是否重复。

      例如：set.add(s1); add方法会调用s1的hashCode方法，计算字符串“abc”的哈希值，哈希值是**96354**，在集合中找有**没有**98354这个哈希值的元素，发现没有就**会把s1存储到集合中**

    - set.add(s2);

      add方法会调用s2的hashCode方法，计算字符串“abc”的哈希值，哈希值是**96354**，发现有**哈希冲突**，s2会调用**equals**方法和哈希值相同的元素进行比较判断元素是否相同，s2.equals(s1)。若返回**true**，就认定两个元素**相同**，不会把s2存储到集合中，若返回为**false**，认定两个元素不同，会把s2存储到集合中

    - Set集合存储元素唯一的**前提**：存储元素（String,Integer,...,Student,Person...）,必须重写hashCode方法和equals方法

  - #### LinkedHashSet集合（继承HashSet集合）

    - **特点**：底层是一个哈希表（数组+链表/红黑树）+链表，多了一条链表（记录元素的存储顺序），保证元素**有序**，同时也是**不允许重复**

  - #### 可变参数

    - **使用前提：**当方法的参数列表数据类型已经确定，但是参数的**个数不确定**，就可以使用可变参数

    - **使用格式**:定义方法时使用

      修饰符 返回值类型 方法名（数据类型.... 变量名）{ }

    - **原理**：可变参数底层就是一个数组，根据传递参数个数不同，会创建不同长度的数组，来存储这些参数。传递参数的个数，可以是0个（不传递），1,2....多个

    - **注意事项:**

      1. 一个方法的参数列表，只能有一个可变参数
      2. 如果方法的参数有多个，那么可变参数必须写在参数列表的末尾

    - ![image-20200807232650750](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200807232650750.png)

    - **例子**：定义计算（0-n）整数和的方法

      已知：计算证书的和，数据类型已经确定为int，但是参数的个数不确定，不知道要计算几个整数的和们就可以使用可变参数

      ```
      public static int add(int...arr){
      	//定义一个初始化的变量，记录累加求和
      	int sum=0;
      	//遍历数组，获取数组中的每个元素
      	for(int i:arr){
      		//累加求和
      		sum+=i;
      	}
      	return sum;
      }
      ```

      

