@[TOC](目录)
导致程序的正常流程被中断的事件称为异常。
# 异常处理
常见的异常处理手段：try，catch，finally，throws
## try...catch...捕获异常
结构：执行代码块1，如果没有异常：顺序向后执行，跳过catch中的代码块，如果出现异常：终止try中代码，运行catch块。
- catch中声明的异常类也可使用其父类（父类的父类），只不过精确性会下降。
```java
try{
	可能出现异常的代码块1
}
catch(声明一个异常类1对象){
	处理异常的代码块2
}catch(声明一个异常类2对象){
	处理异常的代码块3
}
......
```
## finally
无论是否出现异常，finally中的代码都会被执行。

```java
try{
	可能出现异常的代码块1
}
catch(声明一个异常类对象){
	处理异常的代码块2
}
finally{
	......
}
```
## throws
主方法调用method1，
method1电泳method2，
method2中存在异常，

但method2不打算处理异常，
可以使用thorws抛出异常，method1会接到该异常

例：

```java
package exception;
 
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
 
public class TestException {
    public static void main(String[] args) {
        method1();
    }
    private static void method1() {
        try {
            method2();
        } catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    } 
    //找不到文件的异常
    private static void method2() throws FileNotFoundException { 
        File f = new File("d:/LOL.exe");
        System.out.println("试图打开 d:/LOL.exe");
        new FileInputStream(f);
        System.out.println("成功打开"); 
    }
}
```
### throw和throws的区别
1. throws 出现在方法声明上，而throw通常都出现在方法体内。
2. throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某个异常对象。

# 异常分类
异常可以分为：可查异常，运行时异常和错误3种。
## 可查异常 CheckedException
可查异常即必须进行处理的异常，要么try catch住，要么往外抛，谁调用，谁处理，比如 FileNotFoundException
如果不处理，编译器就不让你通过

## 运行时异常 Runtime Exception
不是必须进行try catch的异常，即便不进行try catch，也不会有编译错误。

常见的运行时异常:
- 除数不能为0异常:ArithmeticException
- 下标越界异常:ArrayIndexOutOfBoundsException
- 空指针异常:NullPointerException
```java
public class TestException {
    public static void main(String[] args) {      
        //任何除数不能为0:ArithmeticException
        int k = 5/0;         
        //下标越界异常：ArrayIndexOutOfBoundsException
        int j[] = new int[5];
        j[10] = 10;     
        //空指针异常：NullPointerException
        String str = null;
        str.length();
   }
}
```
## 错误
错误指的是系统级别的异常，通常是内存用光。
错误也不要求强制捕捉。

Error类和Exception类都继承了Throwable类。

# 自定义异常
例：
在Hero的attack方法中，当发现敌方英雄的血量为0的时候，抛出该异常
1. 创建一个EnemyHeroIsDeadException实例
2. 通过throw 抛出该异常
3. 当前方法通过 throws 抛出该异常

```java
package charactor;
//Hero类 
public class Hero {
    public String name;
    protected float hp;
    //攻击英雄的方法
    public void attackHero(Hero h) throws EnemyHeroIsDeadException{
        if(h.hp == 0){
            throw new EnemyHeroIsDeadException(h.name + " 已经挂了,不需要施放技能" );
        }
    }
    public String toString(){
        return name;
    }
    //自定义异常
    class EnemyHeroIsDeadException extends Exception{
        //无参构造
        public EnemyHeroIsDeadException(){
        }
        //有参构造
        public EnemyHeroIsDeadException(String msg){
            super(msg);
        }
    } 
    public static void main(String[] args) {
        Hero garen =  new Hero();
        garen.name = "盖伦";
        garen.hp = 616;
        Hero teemo =  new Hero();
        teemo.name = "提莫";
        teemo.hp = 0;
        //测试异常
        try {
            garen.attackHero(teemo);
        } catch (EnemyHeroIsDeadException e) {
            // TODO Auto-generated catch block
            System.out.println("异常的具体原因:"+e.getMessage());
            e.printStackTrace();
        }
    }
}
```
