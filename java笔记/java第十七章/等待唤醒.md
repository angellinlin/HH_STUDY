# 等待唤醒

## 一、线程状态概述

**New:**至今尚未启动的线程处于这种状态，刚被创建，但是还没启动

**Runnable**: 正在Java虚拟机中执行的线程处于这种状态

**Blocked:**受阻塞并等待某个监视器锁的线程处于这种状态

**Watting:**无限期地等待另一个线程来执行某一特定操作地线程处于这种状态（无限等待状态）

**Timed_Watting:**等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态(计时等待)（如sleep方法）

**Terminated:**已退出的线程状态

**阻塞状态：**具有CPU的执行资格，等待CPU空闲时执行

**休眠状态：**放弃CPU的执行资格，CPU空闲也不执行

 ![img](file:///C:\Users\Lenovo\Documents\Tencent Files\564173731\Image\C2C\A29CB9C2E89277C2506B10CC37FDBCAA.png) 

### 1、Watting状态详解：

![1596022989163](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\1596022989163.png)

Object类中的方法：

1. void  wait()   :  在其他线程调用此对象的  notify() 方法，或 notifyAll() 方法前，导致当前线程等待
2. void  notify ()  :  唤醒在此对象监视器上等待的单个线程，会继续执行wait方法之后的代码。

==注意==：

+ 两个线程必须使用同步代码块包裹起来，保证等待和唤醒只能由一个在执行
+ 同步使用的锁对象必须保证唯一，wait方法和notify方法必须要由同一个锁对象调用
+ wait方法和notiy方法必须要在同步代码块或者使同步函数中使用，因为只有锁对象才能调用wait 和 notify方法

```java
public class WaitAndnotify {
    public static void main(String[] args) {
        Object obj = new Object();//创建一个锁对象
        new Thread(){  //创建一个顾客线程，用匿名内部类
            @Override
            public void run() {
                synchronized (obj){
                    System.out.println("我是顾客，我要告知老板我要的包子种类和数量" );
                    try {
                        obj.wait();//调用wait方法，放弃cpu的执行，进入到WATTING状态，wait方法有异常，使用try catch
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    //唤醒之后执行代码
                    System.out.println("包子做好后，开吃");
                }
            }
        }.start();

        //创建一个老板的线程
        new Thread(){
            @Override
            public void run() {
                try {
                    Thread.sleep(3000); //老板花3秒钟做包子
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                //保证等待和唤醒的线程只有一个能执行，所以需要用同步技术
                synchronized (obj){
                    System.out.println("老板做好包子后叫顾客吃包子");
                    obj.notify();//唤醒线程，执行上面wait之后的代码
                }
            }
        }.start();
    }

```

### 2、wait带参方法

**进入到TimeWaoting（计时等待）有两种方式：**

1. 使用sleep(long m)方法，在毫秒值结束之后，线程睡醒进入到Runnable/Blocked状态
2. 使用wait(long m)方法，wait方法如果在毫秒值结束之后，还没有被notify唤醒，就会自动醒来，线程睡醒进入到Runnable/Blocked状态（obj.wait(3000)）

**唤醒的方法**

1.  void  notify():  唤醒在此对象监视器上等待的单个线程
2. void  notifyAll()：唤醒在此对象监视器上等待的所有线程

## 二、线程通信

### 1、概念：

多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同

如：线程A用来生成包子，线程B用来吃包子，包子可以理解为同一个资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。

**为什么要处理线程间通信？**

多个线程并发执行时，在默认情况下cpu是随机切换线程的，当我么需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行，那么多线程之间需要一些协调通信，一次来帮我们达到多线程共同操作一份数据

**如何保证线程间通信有效利用资源？**

多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作，就是多个线程在操作同一份数据时，避免对同一共享变量的争夺，也就是我们需要通过 一定的手段使各个线程能有效的利用资源，这种手段就是**等待唤醒机制**

**等待唤醒机制就是用于解决线程间通信的问题，使用到的三个方法含义如下**

1. wait： 线程不再活动，不再参与调度，进入wait set当中，因此不会浪费CPU资源，也不会去竞争锁了，这时的线程状态即时WAITTING。，它还要等着别的线程执行一个特别的动作，即是“通知（notify),在这个对象上等待的线程从wait set中释放出来，重新进入到调度队列（ready queue）中
2. notify：则选取所通知对象的wait set 中的一个线程释放
3. notifyAll:则释放所通知对象的wait set上的全部线程

## 三、线程池

我们使用线程时就去创建一个线程，这样实现起来很方便，但是就有这样一个问题：如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程都需要时间

**线程池的概念**：线程池其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源

![1596200446115](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\1596200446115.png)

合理利用线程池的**好处**：

1. 降低资源能耗
2. 提高响应速度
3. 提高线程的可管理性

