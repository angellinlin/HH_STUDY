异常

## 概念

指的是程序在执行过程中出现的非正常情况，最终会导致ajvm的非正常停止。

在java语言中，异常本身是一个类，产生异常就是创建异常对象并抛出一个异常对象，java处理异常的方式就是终端处理。

异常并不是指语法错误，语法错了，编译不会通过，不会产生字节码文件，根本不能运行。

## 一、异常的分类

1. ==Exception:==编译器异常，进行编译（写代码）java程序出现的问题。
2. ==RuntimeException:==运行期异常，程序运行时出现的问题
3. ==Error==:错误，必须修改的代码

## 二、异常产生的过程解析

**当JVM检测出程序异常**

1. Jvm会根据异常产生的原因创建一个对象，这个异常对象包含了异常产生的（内容，原因，位置）
2. 在某个方法中，没有异常的处理逻辑（try...catch)，那么Jvm就会把异常对象抛出给方法调用者main方法来处理。
3. main方法接收到了这个异常对象，main方法也没用异常的处理逻辑，就继续把对象抛出给main方法的调用者Jvm处理
4. Jvm接收到这个异常，会把异常对象以红色字体打印在控制台并终止当前正在执行的java程序。

##  三、throw关键字

1. **作用**：可以使用throw关键字在指定的方法中抛出指定的异常

2. **使用格式：**throw new  xxxException(“异常产生的原因”)***

3. ==注意==: 

   + throw关键字必须写在方法内部
   + throw关键字后边new的对象必须时Exception或Excepton的子类对象
   + throw关键字抛出指定的异常对象，我们就必须处理这个异常对像
     + throw关键字后边创建的时RuntimeException的子类对象，我们可以不处理，默认交给Jvm处理。
     + throw后边如果创建的时编译异常，我们就必须处理这个异常，要么是throws,要么是try...catch
     + *NullPointerException*和*ArrayIndexOutOfBoundsException*是一个运行期异常，我们不用处理，默认交给Jvm处理。

   ```java
   if(arr == null){
       throw new NullPointterExcetiong("传递的是数组的使用范围")
   }
   
   ```
## 四、Object非空判断

```java
public static <T> T requireNonNull(T obj){
    if(obj==null)
        throw new NullPointerException;
    return obj;
//查看指定引用对象是不是null
}
```



##  五、异常处理的第一种方式：throws

==throws==是处理异常的第一种方式，交给别人处理

**作用**：当方法内部抛出异常对象的时候，我们必须处理这个异常对象，可以使用throws关键字处理异常，会把异常对象生命抛出给方法的调用者，最终交给Jvm处理—>中断处理

**使用格式**：在方法声明时使用

```java
   修饰符 返回值类型 方法名（参数列表） throws AAException,BBException...{
       throw new AAAException(“产生原因”)；
       throw new BBBException(“产生原因”)；
   }
```

==注意==：

1. throw关键字必须写在方法声明处
  
2. throws关键字后边声明的异常必须是Excepton或Exception的子类
  
3. 方法内部如果抛出了多个异常对象，那么throws后边也必须声明多个异常
  
   + 如果抛出的多个异常对象有子父类关系，那么直接声明父类异常即可
   
4. 调用了一个声明抛出异常的方法，我们就必须处理声明的异常
  
   + 要么继续使用throws声明抛出，交给方法的调用者处理，最终交给try...catch自己处理异常
      + ==FileNotFoundException==是编译异常，抛出编译异常，就必须处理这个异常，可以使用throws继续声明抛出FileNotFoundException这个异常对象，让方法调用者处理**(Alt+回车选第一个)**。
   
   ```java
      public static void readFile(String filename) throws FileNotFoundException{    if(!filename.equals("c:\\\\a.txt")){        throw new FileNotFoundException("传递的文件路径有误");    }}
   ```
   

​              也可同时抛出多个异常，同时要声明多个异常，或直接声明父类异常

## 六、异常的第二种处理方式：捕获异常 try...catch

**throws抛出异常的缺陷：**如果抛出异常，将终止程序，后面的代码将不会执行

==try...catch==  **格式：**（Alt+回车 选第二个）

```java
   try{
       可能产生异常的代码
   }catch(定义一个异常的变量，用来接收try中抛出的异常对象){
       异常的处理逻辑，出现异常对象之后，怎么处理异常对象
       //一般在工作中，会把异常的信息记录到一个日志中
   }
   ...
       catch(异常类名 变量名){
           
       }
```

==注意==：

1. try中可能会抛出多个异常对象，那么就可以使用多个catch来处理这些异常对象
   2. 如果try中产生了异常，那么就会执行catch中的异常处理逻辑，执行完毕catch中的处理逻辑，继续执行try..catch之后的代码
      + 如果try中没有产生异常，那么就不会执行catch中异常的处理逻辑，执行完try中的代码，**继续执行try...catch之后的代码**
   
```java
    try {
               readFile("d:\\a.txt");
           }catch (FileNotFoundException e){
               System.out.println("传递的文件后缀有误");
           }
   			System.out.println("后续代码");
       }
   
       public static void readFile(String filename) throws FileNotFoundException{
           if(!filename.equals("c:\\\\a.txt")){
               throw new FileNotFoundException("传递的文件路径有误");
           }
       }
```

##  七、Throwable类中三个异常处理方法



1. ==String  getMessage()==:返回此throwable的简短描述
  
2. ==String  toString()==:返回此throwable的详细信息字符串
  
3. ==void  printStackTrace()==:Jvm打印异常对象，打印的异常信息是最全面的
  
   八、finally代码块
   
   **finally:**有一些特定的代码无论异常是否发生，都需要执行，另外，因为异常会引发程序跳转，比如try后面有异常代码，则此异常代码后的语句将不会执行，而跳转catch中，所以导致有些语句执行不到，，而在finally代码块中存放的代码是一定会被执行的。
   
   **格式：**
   
   ```java
      try{
          可能产生异常的代码
      }catch(定义一个异常的变量，用来接收try中抛出的异常对象){
          异常的处理逻辑，出现异常对象之后，怎么处理异常对象
          //一般在工作中，会把异常的信息记录到一个日志中
      }finally{
          //无论是否出现异常都会执行
      }
   ```
   
   ==注意==：
   
   1. finally不能单独使用，必须和try一起使用
      
      2. finally一般用于资源释放（资源回收），无论程序是否出现异常，最后都要资源释放
      
         
   
   ## 八、多异常捕获处理

   1. **多个异常分别处理**

   ​       一个异常对应一个try..catch

   2. **多个异常一次捕获，多次处理**

      有异常的语句都写在try里，然后分别用catch处理
   
      ```java
       try {
                  int[] arr = {1, 2, 3};
      //            System.out.println(arr[3]);
                  List<Integer> lis = List.of(1, 2, 3);
                  System.out.println(lis.get(3));
              }catch (ArrayIndexOutOfBoundsException e) {
                  System.out.println(e);
              }catch (IndexOutOfBoundsException e){
                  System.out.println(e);
              }
      ```
   
      ==注意==：
   
      + 一个try多个catch里边，catch定义的异常变量，如果有子父类关系，那么子类的异常变量必须现在前面，否则就会报错
   
        *ArrayIndexOutOfBoundsException  extends  IndexOutOfBoundsException*
   
   3. **多个异常一次捕获，一次处理**
   
      ```java
       try {
                  int[] arr = {1, 2, 3};
      //            System.out.println(arr[3]);
                  List<Integer> lis = List.of(1, 2, 3);
                  System.out.println(lis.get(3));
              }catch (Exception e) {
           		System.out.println(e);
              }
      ```
   
      Exception类可以处理捕获所有异常
   
      + *运行时异常被抛出可以不处理，即不捕获也不声明抛出，默认给虚拟机处理，终止程序，什么时候不抛出运行异常了，再来执行程序*
      + *如果finally有return语句，永远返回finally中的结果，避免该情况*
   
      
   
   ## 九、子父类异常
   
   + 如果父类抛出了多个异常，子类重写父类方法时，抛出和父类相同的异常或者是父类异常的子类，或者不抛出异常
   
   + 父类方法没有抛出异常，子类重写父类该方法也不可抛出异常，此时子类产生该异常，只能捕获处理，不能声明抛出
   
     ==注意==：**父类异常时什么样，子类异常就什么样**
   
     ​			
   
   
   
   
   
   
   

​          















