# 多线程

## 一、概念

1. **并发：**指两个或多个事件在同一个==时间段==内发生（交替发生），eg:一个人吃两个馒头

2. **并行**：指两个或多个事件在==同一时刻==发生。（同时发生）

3. **进程**：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，时系统运行程序的基本单位；系统运行一个程序就是一个进程从创建、运行到消亡的过程。

4. **内存**：所有的应用程序都要进入到内存中执行，临时存储RAM，点击应用程序执行，进入到内存中占用一些内存执行，进入到内存的程序叫进程。

5. **线程**：线程是进程的一个执行单元，负责当前进程中程序的执行，一个进程至少有一个线程，一个进程中是可以有多个线程的，这个应用程序也可以被成为多线程程序。总之，一个程序运行后至少有一个进程，一个进程可以包含多个线程。

   ![1595854572399](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\1595854572399.png)

6. **线程调度**
   				+ **分时调度**：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间
   				+ **抢占式调度**：抢先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个线程，Java使用的为

7. **主线程**：执行主(main)方法的线程。JVM执行Main方法，main方法会进入到栈内存。JVM会找操作系统开辟一条main方法通向cpu的执行路径，cpu就可以通过这个路径来执行main方法，而这个路径就叫作main（主）线程。
8. **单线程程序**：java程序中只有一个线程，执行从main方法开始，从上到下依次执行。缺陷：单线程一旦发生异常，就不再执行剩下代码

## 二、创建线程类

### 1、创建多线程程序的第一种方式：创建Thread类的子类

*==java.lang.Thread==类：是描述线程的类，我们想要实现多线程程序，就必须继承Thread类*

**实现步骤**:

1. 创建一个Thread类的子类
2. 在Thread类的子类当中重写Thread类中的run方法，设置线程任务（开启线程要做什么？）
3. 创建Thread类的子类对象
4. 调用Thread类中的start方法，开启新的线程，执行run方法

+ void start（）使该线程开始执行；Java虚拟机调用该线程的run方法。

+ 结果是两个线程并发的运行，当前线程（main线程）和另一个线程（创建的线程，执行其run方法）

+ 多次启动一个线程是非法的，特别是当线程已经结束执行后，不能再重新启动。

+ Java程序属于抢占式调度，哪个线程的优先级高，哪个线程就优先执行，同一个优先级，随机选择一个执行

  ![1595895928559](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\1595895928559.png)

### 1.1 获取线程的名称

（1）使用Thread类中的方法==getName()==

+ String getName()  返回该线程的名称

  ```java
  public class Mythread extends Thread {
      @Override
      public void run() {
          String name = getName();
          System.out.println(name);}
  ```

  

（2）可以先获取到当前正在执行的线程：static Thread currentThread()：返回对当前正在执行的线程对象的引用

​          再使用线程中的方法getName()获取线程名称

```java
public class Mythread extends Thread {
    @Override
    public void run() {
    System.out.println(Thread.currentThread().getName());
```

```java
public class Demo01Thread {
    public static void main(String[] args) {
        Mythread mt = new Mythread();
        mt.start();
    /*    for (int i = 0; i < 10; i++) {
            System.out.println("main"+i);
        }*/
//        mt.getName();
//        new Mythread().getName();
        new Mythread().start();
    }
}
```

### 1.2 设置线程名称（了解）

（1）使用Thread类中的方法setName（名字）

+ void setName(String name)  改变线程名称，使之与参数name相同

（2）创建一个带参数的构造方法，参数传递线程的名称，调用父类的带参构造方法，把线程的名称传递给父类，让父类(Thread)给子线程取一个名字

+ Thread(String name)  分配新的Thread对象

### 1.3 sleep方法

public static void sleep(Long millis)：使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行），毫秒数结束后，再继续执行。*sleep方法有异常，抛出或捕获异常后再执行*

```java
public class Demo01Thread {
    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            System.out.println("main"+i);
        }
        Thread.sleep(1000);
```

### 2、创建多线程的第二种方式：实现runnable接口

==java.lang.Runable==

Runnable接口应该由那些打算通过某一线程执行其实例的类来实现，类必须定义一个称为run的无参数方法。

**java.lang.runnable类的构造方法**

+ Thread(Runnable target)  分配新的Thread对象
+ Thread (Runnable target,  String name)  分配新的Thread对象

**实现步骤**：

1. 创建一个Runnable接口的实现类

2. 在实现类中重写Runnable接口的run方法，设置线程任务

3. 创建一个Runnable接口的实现类对象

4. 创建Thread类对象，构造方法中传递Runnable接口的实现类对象

5. 调用Thread类中的start方法，开启新的线程执行run方法

   ```java
   public class Runnable implements java.lang.Runnable {
       @Override
       public void run() {
           for (int i = 0; i < 20; i++) {
           System.out.println(Thread.currentThread().getName()+i);
           }
       }
   }
   
   ```

   ```java
   public class Demo02Thread {
       public static void main(String[] args) {
           Runnable run = new Runnable();
           Thread t = new Thread(run);//创建Thread类对象，构造方法中传递Runnable接口的实现类对象
           t.start();
           for (int i = 0; i < 20; i++) {
               System.out.println(Thread.currentThread().getName() + i);
           }
       }
   }
   ```

   

#### 实现Runnable接口创建多线程程序的好处

1. 避免了单继承的局限性
   + 一个类只能继承一个类，类继承了Thread类就不能继承其他的类，而实现Runable接口还可以继承其他的类，实现其他的接口。
2. 增强了程序的扩展性，降低了程序的耦合性（解耦）
   + 实现Runable接口的方式，把设置线程任务和开启新线程进行了分离（传递不同的实现类，实现不同的任务）
     + 实现类中重写了run方法:  用来设置线程任务
     + 创建Thread类对象，调用start方法:  用来开启新线程

### 3、使用匿名内部类创建线程

**匿名**：没有名字

**内部类**：写在其他类内部的类

**匿名内部类的作用**：简化代码

+ 把子类继承父类，重写父类的方法，创建子类对象合成一步完成
+ 把实现类实现类的接口，重写接口中的方法，创建实现类对象合成一步完成

**匿名内部类最终产物**：子类/实现类对象，而这个类没有名字

**格式：**

```java
new 父类/接口（）{
    重写父类/接口中的方法
}
```

```java
public class Demo03InnerClassThread {
    public static void main(String[] args) {
        //线程的父类是Thread
        new Thread(){
            @Override
            public void run() {
                for (int i = 0; i < 20; i++) {
                    System.out.println(Thread.currentThread().getName()+"---Thread");
                }
            }
        }.start();
        //线程的接口是Runnable
        //Runable run = new RunnableImpl();//多态
       Runnable run =  new Runnable(){
            @Override
            public void run() {
                for (int i = 0; i < 20; i++) {
                    System.out.println(Thread.currentThread().getName()+"---Runnable");
                }
            }
        };
       new Thread(run).start();
        new Thread(new Runnable(){
            @Override
            public void run() {
                for (int i = 0; i < 20; i++) {
                    System.out.println(Thread.currentThread().getName()+"---简化Runnable");
                }
            }
        }).start();
    }
}

```

## 三、线程安全

###1、概述：

多线程访问共享的数据，会产生线程安全问题。（比如电影院三个窗口同时卖一样的票）

**eg:**

```java
public class Demo04 {
    public static void main(String[] args) {
    	ThreadSafe run = new ThreadSafe();
        Thread t1 = new Thread(run);
        Thread t2 = new Thread(run);
        Thread t3 = new Thread(run);
        t1.start();
        t2.start();
        t3.start();
    }
}
```

```java
public class Demo04ThreadSafe implements java.lang.Runnable {
    private int tickets = 10;

    @Override
    public void run() {
        while (true){
            if (tickets>=0) {//进入到if语句的线程开始睡眠，失去了CPU的执行权，等到睡醒后才继续执行if后面的代码，所以会产生-1
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "正在卖第" + tickets + "张票");//三个线程同时执行到这条语句，就会重复
                tickets--;
            }
        }
    }
}
```

==注意==:为了不让线程安全问题产生，我们可以让一个线程在访问共享数据的时候，无论是否失去CPU的执行权，让其他的线程只能等待，等待当前一个线程卖完票再执行，保证只有一个线程在卖票。

### 2、同步代码块

**解决线程安全问题的第一种方法：使用同步代码块**

**格式：**

```java
 synchronized （锁对象）{           
	//可能会出现线程安全问题的代码（访问了共享数据）
   }
```

**注意：**

1. 通过代码块中的锁对象，可以使用任意的对象
2. 但是必须保证多个线程使用的锁对象是同一个
3. 锁对象的作用：把同步代码块锁住，只让一个线程在同步代码块中执行。

```java
public class Demo04ThreadSafe implements java.lang.Runnable {
    private int tickets = 10;
    Object obj = new Object();//创建一个锁对象
    
    @Override
    public void run() {
        while (true){
            
            synchronized (obj){//将代码块放入这个锁对象
            if (tickets>=0) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "正在卖第" + tickets + "张票");
                tickets--;
            }
            }
```

**同步技术的原理**：同步中的线程没有执行完毕不会释放锁对象，同步外的线程没有锁对象进不去同步。

+ 同步保证了只能有一个线程在同步中执行共享数据，保证了安全，程序频繁的判断锁，获取锁，释放锁，程序的效率会降低

### 3、同步方法

**解决线程安全的第二种方式，使用同步方法**

**使用步骤**：

1. 把访问了共享数据的代码抽取出来，放到一个方法当种
2. 在方法上添加synchronized修饰符

**格式**：就是定义方法的格式

```java
修饰符  synchronized  返回值类型  方法名（参数列表）{
    //可能会出现线程安全问题的代码
}
```

```java
 @Override
    public void run() {
        while (true) {
            payTickets();
        }
        //定义一个同步方法
    public synchronized void payTickets() {
        if (tickets >= 0) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
         System.out.println(Thread.currentThread().getName() + "正在卖第" + tickets + "张票");
            tickets--;
        }
    }
```

同步方法也会把方法内部的代码所著，只让一个线程执行，同步方法的锁对象就是实现类对象 new RunnableImpl() ，也就是this

### 3、静态同步方法

就是将方法设为静态public  static  synchronized  void  payTickets()，再把变量设为静态。

静态同步方法的锁对象不能是this,this是创建对象之后产生的，静态方法优先于对象，静态方法的锁对象是本类的class属性，class文件对象（反射）

synchronized （RunnableImpl.class）

### 2、Lock锁

解决线程安全问题的第三种方案：使用Lock锁

***java.util.concurrent.locks.Lock接口***

Lock实现提供了比使用synchronized 方法和语句可获得更广泛的锁定操作。

**Lock接口中的方法：**

1. void  Lock()   获取锁
2. void  unlock()  释放锁

**使用步骤**：（java.util.concurrent.locks.ReetrantLock  implements Lock接口）

1. 在成员位置创建一个ReentrantLock对象
2. 在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁
3. 在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁

```java
public class Demo04ThreadSafe implements java.lang.Runnable {
    private int tickets = 10;
    Lock l = new ReentrantLock();//创建一个Lock对象
    
    @Override
    public void run() {
        while (true){
            
            l.lock();  //获取锁
            if (tickets>=0) {
                try {
                    Thread.sleep(100);
         System.out.println(Thread.currentThread().getName() + "正在卖第" + tickets + "张票");
                tickets--;
                    
               } catch (InterruptedException e) {
                    e.printStackTrace();
                }

               }finally{
                  l.unlock();//无论程序是否异常，都会把锁释放，提高程序效率
               }    
               }
```

