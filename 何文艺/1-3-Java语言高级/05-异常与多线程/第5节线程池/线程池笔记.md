**线程池笔记**  

----------

**一、线程池的概念和原理**  
1.线程池：其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源  
线程池：容器-->集合（ArrayList、HashSet、LinkedList、HashMap）  
2.优点：  
a.降低资源消耗  
b.提高响应速度  
c.提高线程的可管理性  

**二、线程池的代码实现**  
线程池：JDK1.5之后提供的  
1.java.util.concurrent.Executors：线程池的工厂类，用来生成线程池  

    static ExecutorService newFixedThreadPool(int nThreads)：创建一个线程池，该线程池重用固定数量的从共享无界队列中运行的线程
    参数：int nThreads，创建线程池中包含的线程数量
    返回值：ExecutorService接口，返回的是ExecutorService接口的实现类对象，我们可以使用ExecutorService接口接收（面向接口编程）

2.java.util.concurrent.ExecutorService：线程池接口，用来从线程池中获取接口，调用start方法，执行线程任务  

    Future<?> submit(Runnable task)：提交一个可运行的任务执行，并返回一个表示该任务的未来
    void shutdown()：启动有序关闭，其中先前提交的任务将被执行，但不会接受任何新任务，也就是关闭/销毁线程池  

3.线程池的使用步骤：  
    a.使用线程池的工厂类Executors里面提供的静态方法newFixedThreadPool(int nThreads)生产一个指定线程数量的线程池  
    b.创建一个类实现Runnable接口，重写run方法，设置线程任务  
    c.调用ExecutorService接口中的方法submit(Runnable task)，传递线程任务（实现类），开启线程，执行run方法  
    d.调用ExecutorService接口中的方法shutdown()，销毁线程池（不建议执行）  

ThreadPool.java  

```java
package thread;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPool {
    public static void main(String[] args) {
        //1.使用线程池的工厂类Executors里面提供的静态方法newFixedThreadPool(int nThreads)生产一个指定线程数量的线程池
        ExecutorService es = Executors.newFixedThreadPool(2);
        //2.创建一个类实现Runnable接口，重写run方法，设置线程任务
        //3.调用ExecutorService接口中的方法submit(Runnable task)，传递线程任务（实现类），开启线程，执行run方法
        es.submit(new RunnableImpl());
        es.submit(new RunnableImpl());
        es.submit(new RunnableImpl());
        //4.调用ExecutorService接口中的方法shutdown()，销毁线程池（不建议执行）
        es.shutdown();
    }
}
```

RunnableImpl.java  

```java
package thread;

//2.创建一个类实现Runnable接口，重写run方法，设置线程任务
public class RunnableImpl implements Runnable {
    @Override
    //2.在实现类中重写Runnable接口的run方法，设置线程任务
    public void run() {
        System.out.println(Thread.currentThread().getName() + "执行了");
    }
}
```

执行结果：  
pool-1-thread-2执行了
pool-1-thread-1执行了
pool-1-thread-2执行了