### 3.4.1 异常

#### 3.4.1.1异常的分类

java.lang.Throwable类：是java语言中所有异常和错误的超类。
   Exception：编译期异常，进行编译（写代码）java程序出现的问题。
      RuntimeException：运行期异常，java程序运行过程中出现的问题。
      异常即相当于程序得了一个小毛病（感冒），把异常处理掉，程序就可以继续执行（吃点药，继续工作）
   Error：错误
      错误就相当于程序得了一个无法治愈的毛病（非典，艾滋），必须修改源代码，程序才能继续执行。

```
//异常
int[] arr = {1, 2, 3};
System.out.println(arr[0]);
try {
    //可能会出现异常的代码
    System.out.println(arr[3]);
}catch (Exception e){
    //异常的处理逻辑
    System.out.println(e);

}
System.out.println("=========");
//Error：错误
//错误就相当于程序得了一个无法治愈的毛病（非典，艾滋），必须修改源代码，程序才能继续执行。
//OutOfMemoryErro:必须修改源代码，让数组的大小变小
//int[] arr1=new int[1024*1024*1204];
```

 

#### 3.4.1.2异常的产生过程解析

```
public static void main(String[] args) {
    int[] arr = {1, 2, 3};
    getElement(arr, 3);
}

public static int getElement(int[] arr, int index) {
    int element = arr[index];
    return element;
}
/*Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 3
at cn.swjtu.Exception_day072001.Demo02Exception.getElement(Demo02Exception.java:14)
at cn.swjtu.Exception_day072001.Demo02Exception.main(Demo02Exception.java:10)*/
```

程序产生异常的过程：

1、访问了数组的3索引，而数组是没有3索引的，这时候JVM就会检测出程序异常，JVM就会做两件之情：

​    （1）JVM会根据异常产生的原因创建一个异常对象，这个对象包含了异常产生的（内容、原因、位置）new ArrayIndexOutOfBoundException(“3”);

​    （2）在getElement方法中，没有异常的处理逻辑（try…catch），那么JVM就会把一场对象抛出给方法的调用者main方法来处理这个异常。

2、new ArrayIndexOutOfBoundException(“3”);

main方法接收到了这个异常对象，main方法也没有异常的处理逻辑，继续把对象抛出给main方法的调用者JVM处理。

3、new ArrayIndexOutOfBoundException(“3”);

JVM接收到了这个异常对象，做了两件事情：

​    （1）把异常对象（内容，原因，位置）以红色字体打印在控制台；

​    （2）JVM会终止当前正在执行的java程序à中断处理

​                               

#### 3.4.1.3异常的处理

**一、抛出异常throw****关键字：**
 作用：可以使用throw关键字在指定的方法中抛出指定的异常。
 使用格式：throw new XXXException("异常产生的原因");
 注意：
 1.throw关键字必须写在方法的内部；
 2.throw关键字后边new的对象必须是Exception或者Exception的子类对象；
 3.throw关键字抛出的指定异常对象，我们就必须处理这个异常对象：
 （1）throw关键字后边创建的是RuntimeException或者RuntimeException的子类对象，我们可以默认不处理，默认交给JVM处理（打印异常对象，中断程序）
 (2)throw关键字后边创建的是编译异常（写代码时就报错），我们就必须处理这个异常没要么throws，要么try...catch

```
/*
定义一个方法获取指定索引处的元素
参数：int[] arr,int index
工作中，我们必须首先对方法中传递过来的参数进行合法性校验
如果参数不合法，那么我们就必须使用抛出异常的方式，告知方法的调用者，传递的参数有问题
注意：NullPointerException和ArrayIndexOutOfBoundsException都是运行期异常，我们不用处理，交给JVM处理。
 */
public static int getElement(int[] arr, int index) {
    /*
    我们可以对传递过来的数组，进行合法性校验
    如果数组的值是null,那我们就抛出空指针异常，告知方法调用者：传递的数组值是null
     */
    if (arr == null) {
        throw new NullPointerException("传递的数组值是null");
    }
    /*
    我们可以对传递过来的参数index进行合法性校验
    如果index大小不在数组的索引范围内，那我们就抛出数组索引越界异常，告知方法调用者：传递的索引超出了数组的使用范围
     */
    if (index < 0 || index > arr.length - 1) {
        throw new ArrayIndexOutOfBoundsException("传递的索引超出了数组的使用范围");
    }
    int e = arr[index];
    return e;
}
```

 

**二、Objects****非空判断requireNonNull**

Objects类中的静态方法：
   public static <T> requireNonNull(T obj):查看指定引用对象不是null
   源码：public static <T> requireNonNull(T obj){
     if(obj==null)
       throw new NullPointerException();
     return obj;

因此，在写代码时对传递的参数进行合法判断可用：

```
//Objects.requireNonNull(obj);
Objects.requireNonNull(obj, "传递对象的值是null");
```

 

**三、声明异常throws****（异常处理的第一种方式）**

throws关键字：异常处理的第一种方式，交给别人处理
 作用：
 1、当方法内部抛出异常对象的时候，那么我么就必须处理这个异常对象；
 2、可以使用throws关键字处理异常，会把异常对象声明抛出给方法的调用者处理（自己不处理，给别人处理）最终交给JVM处理-->中断处理。
 使用格式：在方法声明时使用。
 修饰符 返回值类型 方法名（参数列表） throws AAAException，BBBException，...{
   throw new AAAException("产生原因");
   throw new BBBException("产生原因");
   ......
   }
 注意事项：
 1、throws关键字必须写在方法声明处
 2、throws关键字后边声明的异常必须是Exception或Exception的子类；
 3、方法内部如果抛出了多个异常对象，那么throws后边必须也声明多个异常
   如果抛出的多个异常对象有字符类关系，那么声明父类异常即可。
 3、调用了一个声明抛出异常的方法，我们就必须处理声明的异常：
   要么继续使用throws声明抛出，交给方法的调用者处理，最终交给JVM
   要么try..catch自己处理异常

```
/*
定义一个方法，对传递的文件路径进行合法性判断
如果路径不是"C:\\a.txt"，那么我们就抛出文件找不到异常对象，告知方法的调用者
注意：FileNotFoundException是编译异常，抛出了编译异常，就必须处理这个异常
     可以使用throws继续声明抛出FileNotFoundException这个异常对象，让方法的调用者处理
     FileNotFoundException extends IOException,可直接声明IOException即可。
 */
//public static void readFile(String fileName) throws FileNotFoundException,IOException {
public static void readFile(String fileName) throws FileNotFoundException,IOException {
    if(!fileName.equals("c:\\a.txt")){
        throw new FileNotFoundException("传递的文件路径不是c:\\a.txt");
    }
    /*
    如果传递的路径不是.txt结尾
    那我们就抛出IO异常对象，告知方法调用者，文件的后缀名不对
     */
    if(!fileName.endsWith(".txt")) {
        throw new IOException("文件的后缀名不对");
    }
    System.out.println("路径正确，读取文件");
}
```

 

**四、捕获异常cat..catch****（异常处理的第二种方式）**

try..catch异常处理的第二种方式，自己处理异常
 格式：
 *try{
   //**可能会产生异常的代码
 }catch(**定义一个异常的变量，用来接收try**中抛出的异常对象){
   //**异常的处理逻辑，产生异常对象后，怎么处理异常对象
   //**一般在工作中，会把异常的信息记录到一个日志中
 }
 ...
 catch(**异常类名* *变量名){
 
 }
\* 注意：
 1、try中可能会抛出多个异常对象，那么久可以使用多个catch来处理这些异常；
 2、如果try中产生了异常，那么就会执行catch中的异常处理逻辑，执行完毕catch中的处理逻辑，继续执行try..catch之后的代码；
   如果try中没有产生异常，那么就不会执行catch中异常的处理逻辑，执行完try中的代码，继续执行try..catch之后的代码。

```
public static void main(String[] args) {
    try{
        readFile("c:\\a.exe");
    }catch(IOException e){
        System.out.println("catch,传递的文件后缀不是.txt");//try中抛出什么异常对象，catch就定义什么以上变量，用于接收
    }
    System.out.println("后续代码");
}

public static void readFile(String fileName) throws IOException {
    /*
    如果传递的路径不是.txt结尾
    那我们就抛出IO异常对象，告知方法调用者，文件的后缀名不对
     */
    if(!fileName.endsWith(".txt")) {
        throw new IOException("文件的后缀名不对");
    }
}
```

 

**五、****Throwsable****类中****3****个异常处理的方法**

Throwable类中3个异常处理的方法
 String getMessage()返回throwable的简短描述
 String toString()返回此throwable的详细信息字符串
 void printStackTrace() JVM打印异常对象，默认此方法，打印的异常信息最全面

 

```
System.out.println(e.getMessage());  //文件的后缀名不对
System.out.println(e.toString());  //java.io.IOException: 文件的后缀名不对
System.out.println(e);  //同上
/*
java.io.IOException: 文件的后缀名不对
  at cn.swjtu.Exception_day072002.Demo01TryCatch.readFile(Demo01TryCatch.java:54)
      at cn.swjtu.Exception_day072002.Demo01TryCatch.main(Demo01TryCatch.java:28)
*/
  e.printStackTrace();
```

 

**六、****finally****代码块**

格式：
 try{
   //可能会产生异常的代码
 }catch(定义一个异常的变量，用来接收try中抛出的异常对象){
   //异常的处理逻辑，产生异常对象后，怎么处理异常对象
   //一般在工作中，会把异常的信息记录到一个日志中
 }
 ...
 catch(异常类名 变量名){
 
 }finally{
   无论是否异常都会执行的代码
 }
 注意：
 1、finally不能单独使用，必须和try一起使用
 2、finally一般用于资源释放（回收），无论程序是否出现异常，最后都要资源释放（IO）

**七、异常注意事项**

**（一）多异常的捕获处理**
 1、多个异常，分别捕获，分别处理。
 2、多个异常，一次捕获，多次处理。
 一个try里边多个catch注意事项：
 catch中定义的异常变量，如果有父子关系，那么子类的异常变量必须写在上边，否则就会报错。
 ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException
 try如果出现了异常对象，会把异常对象抛出给catch处理，抛出的异常对象，会从上到下依次赋值给catch中定义的异常变量。

  
 3、多个异常，一次捕获，一次处理
 运行时异常被抛出可以不处理，即不捕获也不声明抛出。
 默认给虚拟机处理，终止程序，什么时候不抛出运行时异常了，再继续执行程序。

```
try{
    int []arr={1,2,3};
    System.out.println(arr[3]);
    List<Integer> list = List.of(1, 2, 3);
    System.out.println(list.get(4));
}catch (Exception e){
    System.out.println(e);
}
System.out.println("后续代码！");
```

 

（二）如果finally中有return语句，永远返回finally中的结果，避免该情况。

 

（三）子父类异常*
\* 1.如果父类抛出了多个异常，子类重写父类方法时，抛出和父类相同的异常或者是父类异常的子类或者不抛出。
 2.父类方法没有抛出异常，子类重写父类方法时也不可抛出异常.此时子类产生该异常，只能捕获处理，不能声明抛出。
 **注意：父类异常是什么样，子类异常就什么样。**

 

八、自定义异常类：
 java提供的异常类，不够我们使用，需要自己定义一些异常类。
 格式：

*public class XXXException extends Exception/RuntimeException{
\*   *添加一个无参构造方法
\*   *添加一个带异常信息的构造方法
\*   *（查看源码发现，所有的异常类都会有一个带异常信息的构造方法，内部调用父类异常信息的构造方法，让父类来处理这个异常信息）
 }
\* 注意：
 1、自定义异常类一般都是以Exception结尾，说明该类是一个异常类；
 2、自定义异常类，必须继承Exception或者RuntimeException
   继承Exception：那么自定义的异常类就是一个编译器异常，如果方法内部抛出了编译器异常，就必须处理这个异常，要么throws，要么try...catch
   继承RuntimeException：那么自定义的异常类就是一个运行期异常，无需处理，交给虚拟机处理（中断处理）。

 

要求：模拟注册操作，如果用户名已经存在，则抛出异常并提示：亲，该用户名已经被注册！
 分析：
 1、使用数组保存已经注册过的用户名（数据库）
 2、使用Scanner获取用户的注册名（前端、页面）
 3、定义一个方法，对输入的用户名进行判断
   遍历数组，获取每一个用户名
   判断比较
     true：抛出RegisterException异常，告知用户“亲，该用户名已经被注册！”
     false：继续遍历比较
   遍历结束，依然没有重复则，提示用户“注册成功！*”*

```
public class RegisterException extends Exception/* RuntimeException*/{
    //添加一个无参构造方法
    public RegisterException(){

    }
    //添加一个带异常信息的构造方法
    //查看源码发现，所有的异常类都会有一个带异常信息的构造方法，内部调用父类异常信息的构造方法，让父类来处理这个异常信息
    public RegisterException(String message){
        super(message);
    }

}
```

 

```
//1、使用数组保存已经注册过的用户名（数据库）
public static String[] userNames = {"孙尚香", "王昭君", "芈月"};

public static void main(String[] args) /*throws RegisterException*/ {
    //2、使用Scanner获取用户的注册名（前端、页面）
    Scanner sc=new Scanner(System.in);
    System.out.println("请输入要注册的用户名：");
    String username = sc.next();
    checkUsername(userNames,username);
}
//3、定义一个方法，对输入的用户名进行判断
public static void checkUsername(String[] userNames,String username) /*throws RegisterException*/ {
    for (String name : userNames) {
        if(name.equals(username)){
            try {
                throw new RegisterException("亲，该用户名已经被注册！");
            } catch (RegisterException e) {
                e.printStackTrace();
                return;  //结束循环
            }


        }
    }
    System.out.println("注册成功！");
}
```

 