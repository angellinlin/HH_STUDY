### 3.4.2 线程实现方式

#### 一、并发与并行

并发：指两个或多个事件在同一个时间段内发生（交替执行）

并行：指两个或多个事件在同一时刻发生（同时执行）

​                               

 

#### 二、进程与线程

**进程**：是指一个内存中运行的应用程序。每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是从创建、运行到消亡的过程。

**线程**：线程是进程中的一个执行单元。一个进程至少有一个线程，可以有多个线程。

 

 

 

#### 三、线程调度

分时调度和抢占式调度。

分时调度：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间。

抢占式调度：优先让优先级高的线程使用CPU，如果线程优先级相同，那么会随机选择一个（线程随机性），java使用的为抢占式调度。

 

#### 四、主线程

主线程：执行主方法（main）的线程。
 
 单线程程序：java程序中只有一个线程，执行从main方法开始，从上到下依次执行。
 
 JVM执行main方法，main方法会进入到栈内存，JVM会开辟一条main方法通向CPU的执行路径。CPU就可以通过这个路径来执行main方法，而这个路径有一个名字，叫做主线程（main线程）。

 

 

#### 五、创建线程

**（一）创建多线程的第一种方式：创建Thread****的子类**
 java.lang.Thread类：是描述线程的类，我们想要实现多线程程序，就必须继承Thread类。
 
 **1****、实现步骤：
** （1）创建一个Thread类的子类
 （2）在Thread类的子类中重写Thread类的run方法，设置线程任务（开启线程要做什么？）
 （3）创建Thread的子类对象
 （4）调用Thread类中的方法start方法，开启新的线程，执行run方法。
   void start() 使该线程开始执行；Java 虚拟机调用该线程的 run 方法。
   结果是两个线程并发地运行；当前线程（main线程）和另一个线程（创建的新线程，执行其 run 方法）。
   多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。
 
 java程序属于抢占式调度，哪个线程优先级高，哪个线程优先执行；同一个优先级，随机选择一个执行。

 

**2****、随机打印结果实现原理：**

 

**3****、内存图解**

多线程的好处：多个线程之间互不影响（因为在不同的栈空间）

 

 

**（二）创建线程的第二种方式：实现Runnable****接口\*
\*** java.lang.Runnable接口
   Runnable接口应该由那些打算通过某一线程执行其实例的类来实现。类必须定义一个称为 run 的无参数方法。
 java.lang.Thread类的构造方法
   Thread(Runnable target) 分配新的 Thread 对象。
   Thread(Runnable target, String name) 分配新的 Thread 对象。
 实现步骤：
 （1）创建一个Runnable接口的实现类；
 （2）在实现类中重写Runnable接口的run方法，设置线程任务；
 （3）创建一个Runnable接口的实现类对象；
 （4）创建Thread类对象，构造方法中传递Runnable接口的实现类对象；
 （5）调用Thread类中的start方法，开启新线程执行run方法。

```
//（1）创建一个Runnable接口的实现类；
public class RunnableImpl implements Runnable{
    //2）在实现类中重写Runnable接口的run方法，设置线程任务；
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }
}
```

 

```
public static void main(String[] args) {
    //（3）创建一个Runnable接口的实现类对象；
    RunnableImpl run=new RunnableImpl();
    //（4）创建Thread类对象，构造方法中传递Runnable接口的实现类对象；
    Thread th=new Thread(run);
    //（5）调用Thread类中的start方法，开启新线程执行run方法。
    th.start();


    System.out.println(Thread.currentThread().getName());
}
```

 

**（三）Thread****和Runnable****的区别**

实现Runnable接口创建多线程程序的好处：
 1、避免了单继承的局限性
   一个类只能继承一个类，类继承了Thread类就不能继承其他的类；
   实现了Runnable接口，还可以继承其他的类，实现其他的接口。
 2、增强了程序的扩展性，降低了程序的耦合性（解耦）
   实现Runnable接口的方式，把设置线程任务和开启新线程进行了分离（解耦）
   实现类中重写了run方法：用来设置线程任务
   创建Thread类对象。调用start方法：用来开启新线程。

 

```
RunnableImpl run1=new RunnableImpl();
RunnableImpl2 run2=new RunnableImpl2();
//（4）创建Thread类对象，构造方法中传递Runnable接口的实现类对象；
//Thread th=new Thread(run1);//打印线程名称
Thread th=new Thread(run2);//打印hello
```

 

**（四）匿名内部类实现多线程的创建**

匿名：没有名字
 内部类：写在其他类内部的类
 
 匿名内部类的作用：简化代码
   把子类继承父类，重写父类的方法没创建子类对象合一步完成
   把实现类实现接口，重写接口中的方法，创建实现类对象合成一步完成。
 匿名内部类的最终产物：子类/实现类对象，而这个类没有名字。
 格式：
 new 父类/接口{
   重复父类/接口中的方法
 };

 

```
//线程的父类Thread
    //new MyThread().start();
    new Thread(){
        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName());
        }
    }.start();

    //线程的接口Runnable
    //new RunnableImpl
    Runnable run=new Runnable(){
        @Override
        public void run() {
            for (int i = 0; i < 20; i++) {
                System.out.println(Thread.currentThread().getName()+" "+i);
            }
        }
    };
    new Thread(run).start();

    //简化接口的方式
    new Thread(new Runnable() {
        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName());
        }
    }).start();
}
```

 

 

#### 六、Thread类的常用方法

**（一）获取线程的名称：**
 1、使用Thread类的方法String getName()
 2、可以先获取到当前正在执行的线程，使用县城中的getName()再获取线程的名称。
 static Thread currentThread() 返回对当前正在执行的线程对象的引用。

*线程的名称：
\*   *主线程:main
\*   *新线程：Thread-0**，Thread-1*

 

```
//获取线程名称1
 String name=getName();
 System.out.println(name);

 //获取线程名称2
 //首先获取线程
Thread mt = currentThread();       
 String name = mt.getName();
 System.out.println(name);

 //链式编程
 System.out.println(Thread.currentThread().getName());
```

 

**（二）设置线程的名称**

设置线程的名称：（了解）
 1、使用Thread类的方法setName(名字)
 void setName(String name) 改变线程名称，使之与参数 name 相同。
 2、创建一个带参数的构造方法，参数传递线程的名称，然后调用父类的带参构造方法，把线程名称传递给父类，让父类Thread给子线程取一个名字。
 Thread(String name) 分配新的 Thread 对象。

 

**（三）sleep****方法**

static void sleep(long millis) 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）。
 毫秒数结束后，线程继续执行。(静态方法，直接用类调用)

 