### 3.4.3 线程同步机制

#### 一、线程安全问题

多线程访问了共享的数据，会产生安全问题。

​                               

**三个窗口同时卖100****张票的案例**

```
public class RunnableImpl implements Runnable {
    //定义一个多线程共享的票源
    private int ticket = 100;
    //设置线程任务，卖票
    @Override
    public void run() {
        //使用死循环，让卖票重复循环
        while (true) {
            //提高安全问题出现的概率
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //先判断票是否存在
            if (ticket > 0) {
                //票存在，卖票 ticket--;
                System.out.println(Thread.currentThread().getName() + "正在卖第" + ticket + "张票");
                ticket--;
            }
        }

    }
}
```

 

```
public static void main(String[] args) {
    //创建实现类对象
    RunnableImpl run = new RunnableImpl();
    //创建Thread类对象，构造方法的参数使用实现类对象
    Thread th0 = new Thread(run);
    Thread th1 = new Thread(run);
    Thread th2 = new Thread(run);
    //开启多线程
    th0.start();
    th1.start();
    th2.start();
}
```

 

#### 二、线程安全问题产生的原理

程序出现了安全问题：卖票出现了重复的票和不存在的票。

 

注意：线程安全问题是不能产生的。我们可以让一个线程在访问共享数据时，无论是否失去了CPU的执行权，让其他的线程只能等待，等待当前线程卖完票，其他线程再进行卖票。保证始终只有一个线程在卖票。

 

#### 三、解决线程安全问题

**（一）方法一：同步代码块**

卖票案例出现了线程安全问题，卖出了不存在的票和重复的票。
 解决线程安全的一种方案：使用同步代码块。
 格式：*synchronized(**锁对象){
\*   *可能会出现线程安全的代码（访问了共享数据的代码）
 }*
 注意：
 1、同步代码块的锁对象，可以使用任意的对象。
 2、但是必须保证多个线程使用的锁对象是同一个。
 3、锁对象的作用：
   把同步代码块锁住，只让一个线程在同步代码块中执行。

```
//创建一个锁对象
Object obj = new Object();
run方法中：
synchronized (obj){
    //先判断票是否存在
    if (ticket > 0) {
        //票存在，卖票 ticket--;
        System.out.println(Thread.currentThread().getName() + "正在卖第" + ticket + "张票");
        ticket--;
    }
}
```

 

**（二）方法二****----****同步方法**

*修饰符 synchronized* *返回值类型* *方法名（参数列表）{*

*可能会出现线程安全的代码（访问了共享数据的代码）
\* *}*

 

同步方法会把方法内部的代码锁住，只让一个线程执行。

同步方法的锁对象是谁？其实就是实现类对象new RunnableImpl()，也就是this。

 

**静态同步方法：**

*修饰符 static synchronized* *返回值类型* *方法名（参数列表）{*

*可能会出现线程安全的代码（访问了共享数据的代码）
\* *}*

静态方法的锁对象是class属性-->class文件对象（反射）

**（三）解决线程安全问题的第三种方案：使用****Lock****锁\*
\*** java.util.concurrent.locks.Lock接口
 Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作.
 Lock接口中的方法：
   void lock()获取锁
   void unlock()释放锁
 java.util.concurrent.locks.ReentrantLock implements Lock接口
 使用步骤：
 1、在成员位置上创建一个ReentrantLock对象；
 2、在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁。
 3、在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁。

 

#### 四、同步技术的原理

使用了一个**锁对象**，这个锁对象叫**同步锁**，也叫**对象锁、对象监视器**。

3个线程一起抢夺CPU的指向权，谁抢到了谁执行run方法进行卖票。

​    t0抢到了CPU的执行权，执行run方法，遇到synchronized同步代码块。这时to会检查同步代码块是否有锁对象，发现有，就会获取到锁对象，进入到同步中执行。

​    t1抢到了CPU的执行权，执行run方法，遇到synchronized同步代码块。这时t1会检查同步代码块是否有锁对象，发现没有，t1就会进入到阻塞状态，一直等待t0线程归还锁对象，一直到t0执行完同步中的代码，就会把锁对象归还给锁对象，这时t1才能获取到锁对象。

 

总结：同步中的线程没有执行完毕，不会释放锁。

同步外的线程，没有锁进不去同步。

 

同步保证了只能有一个线程在同步中执行共享数据。保证了安全。

程序频繁的判断锁、获取锁、释放锁，降低了程序的效率。

 

 