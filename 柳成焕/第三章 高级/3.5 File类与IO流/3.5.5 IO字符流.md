### 3.5.5 IO字符流

#### 一、字符输入流Reader& 文件字符输入流FileReader

**（一）java.io.Reader:****字符输入流**：用于读取字符流的最顶层的父类，定义了一些共性的成员方法，是一个抽象类。
 共性的成员方法
 int read() 读取单个字符并返回。
 int read(char[] cbuf) 一次读取多个字符，存入数组
 void close() 释放资源
 
 **（二）java.io.FileReader** extends InoutStreamReader extends Reader文件字符输入流
 作用：把硬盘文件中的数据以字符的方式读取到内存中。
 构造方法：
 构造方法摘要 
 FileReader(File file) 
 FileReader(String fileName) 
 参数：读取文件的数据源。
   String fileName文件的路径，File file一个文件
 作用：
   1、创建一个FileReader对象；
   2、会把FileReader对象指向要读取的文件。

 

（三）字符输入流的使用步骤【重点】

1、创建一个FileReader对象。构造方法中绑定要读取的数据源；
 2、使用FileReader对象中的方法read读取文件；
 3、释放资源。
 String(char[] value) 把字符数组转换为字符串。
 String(char[] value, int offset, int count) 把字符数组的一部分转换为字符串。

```
FileReader fr = new FileReader("Stream0727\\c.txt");
//读取单个字符
/*int len = 0;
while((len=fr.read())!=-1){
    System.out.print((char)len);
}*/

//一次读取多个字符
int len = 0;
char[] chars = new char[1024];
while ((len = fr.read(chars)) != -1) {
    System.out.println(new String(chars,0,len));
}
fr.close();
```

#### 二、字符输出流Writer

**（一）java.io.Writer****字符输出流**：是所有字符输出流最顶层的父类，是一个抽象类。
 共性成员方法：
   abstract void close() 关闭此流，但要先刷新它。
   void flush() 刷新该流的缓冲。
   void write(char[] cbuf) 写入字符数组。
   void write(char[] cbuf, int off, int len) 写入字符数组的某一部分。
   void write(int c) 写入单个字符。
   void write(String str) 写入字符串。
   void write(String str, int off, int len) 写入字符串的某一部分。
 

**（二）FileWriter****文件字节输出流**：把内存中的字符数据写入到文件中。
 构造方法：
   FileWriter(File file)
   FileWriter(String fileName) 
   参数：写入数据的目的地
   String fileName文件的路径，File file文件
 构造方法的作用：
   1、创建一个FileWriter对象
   2、会根据构造方法中传递的文件/文件的路径，创建文件
   3、会把FileWriter对象指向创建好的文件。

 

**（三）字符输出流的使用步骤【重点】**
   1、创建一个 FileWriter对象，构造方法中绑定要写入数据的目的地；
   2、使用FileWriter对象中的方法write，把数据写入到内存缓冲区中（字符转换为字节的过程）；
   3、使用FileWriter对象中的flush方法，把内存缓冲区中的数据刷新到文件中；
   4、释放资源（会先把内存缓冲区中的数据刷新到文件中）。

```
// 1、创建一个  FileWriter对象，构造方法中绑定要写入数据的目的地；
 FileWriter fw=new FileWriter("Stream0727\\c.txt");
 //2、使用FileWriter对象中的方法write，把数据写入到内存缓冲区中（字符转换为字节的过程）；
 fw.write(97);
 // 3、使用FileWriter对象中的flush方法，把内存缓冲区中的数据刷新到文件中；
 fw.flush();
 // 4、释放资源（会先把内存缓冲区中的数据刷新到文件中）。
fw.close();
```

 

（四）flush方法和close方法的区别

  flush：刷新缓冲区，流对象可以继续使用。
   close：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。

```
// 1、创建一个  FileWriter对象，构造方法中绑定要写入数据的目的地；
FileWriter fw=new FileWriter("Stream0727\\c.txt");
//2、使用FileWriter对象中的方法write，把数据写入到内存缓冲区中（字符转换为字节的过程）；
fw.write(97);//c.txt中变为a
// 3、使用FileWriter对象中的flush方法，把内存缓冲区中的数据刷新到文件中；
fw.flush();
//刷新之后，流可以继续使用
fw.write(98);  //c.txt中变为ab
// 4、释放资源（会先把内存缓冲区中的数据刷新到文件中）。
fw.close();
// IOException: Stream closed异常，close方法之后，流已经关闭了，已经从内存中消失了，不能再被使用了。
fw.write(99);
```

 

**（五）字符输出流写数据的其他方法**
 void write(char[] cbuf) 写入字符数组。
 abstract void write(char[] cbuf, int off, int len) 写入字符数组的某一部分。
 void write(String str) 写入字符串。
 void write(String str, int off, int len) 写入字符串的某一部分。

```
FileWriter fw = new FileWriter("Stream0727\\d.txt");
//void write(char[] cbuf) 写入字符数组
char[] chars1 = {'a', 'b', 'c', 'd'};
fw.write(chars1);
//abstract void write(char[] cbuf, int off, int len) 写入字符数组的某一部分。
fw.write(chars1,0,2);
//void write(String str) 写入字符串。
fw.write("你好呀");
//void write(String str, int off, int len) 写入字符串的某一部分。
fw.write("上海浦东发展银行",4,4);  //发展银行
fw.close();
```

 

**（六）字符输出流的续写和换行**
 1、续写：使用两个参数的构造函数
 FileWriter(String fileName, boolean append)
 FileWriter(File file, boolean append)
 参数：boolean append续写开关
    true：不会创建新的文件覆盖，可以续写
    false：会创建新的文件覆盖原文件
 2、换行：换行符号
 windows:\r\n linux:\n mac:\r

 

#### 三、使用try…catch处理流中的异常

**（一）在JDK1.7****之前使用try...catch finally****处理流中的异常【重点掌握】**
 格式：
 try{
   可能会产生异常的代码
 }catch(异常类变量 变量名){
   异常处理逻辑
 }finally{
   一定会执行的代码
   资源释放
 }

```
/*提高变量fw的作用域，让finally可以使用
变量在定义时可以没有值，但在使用时必须有值
 fw = new FileWriter("Stream0727\\d.txt", true);如果执行失败，则  fw.close();中的fw没有值，就会报错。*/
FileWriter fw = null;
try {
    fw = new FileWriter("w:\\Stream0727\\d.txt", true);
    for (int i = 0; i < 10; i++) {
        fw.write("hello" + i + "\r\n");
    }
} catch (IOException e) {
    System.out.println(e);//FileNotFoundException: w:\Stream0727\d.txt (系统找不到指定的路径。)
} finally {
    //一定会执行的代码
    /*创建对象如果失败了，fw默认值就是null。
    null是不能直接调用方法的，会抛出NullPointerException异常
    需要增加一个判断，不是null就把资源释放*/
    if (fw != null) {
        try {
            //fw.close();声明抛出了异常，所以我们必须处理
            fw.close();
        } catch (IOException e) {
            System.out.println(e);
        }
    }
}
```

 

（二）**JDK7****的新特性：***
\* 在try后边可以增加一个()，在括号中可以定义流对象。那么这个流对象的作用域就在try中有效。
 try中的代码执行完毕，就自动把流对象释放，不用写finally了。
 格式：
 try(定义流对象；定义流对象；......){
   可能会产生异常的代码
 }catch(异常类变量 变量名){
   异常处理逻辑
 }

```
try ( //1、创建一个FileInputStream对象。构造方法中绑定要读取的数据源。
      FileInputStream fis = new FileInputStream("F:\\1.png");
      //2、创建一个FileOutputStream对象，构造方法中绑定要写入的目的地。
      FileOutputStream fos = new FileOutputStream("D:\\1.png");) {
    //3、使用字节输入流对象的方法read读取文件；
    //一次读取一个字节的方式（速度慢）
int len = 0;
    while ((len = fis.read()) != -1) {
        //4、使用字节输出流对象的方法write写入目的地文件中；
        fos.write(len);
    }
} catch (IOException e) {
    System.out.println(e);
}
```

 

**（三）JDK9****的新特性：**
 try的前边可以定义流对象，try后边的括号中可以直接引入流对象的名称（变量名），
 在try代码块执行完毕后，流对象也可以释放掉，不用写finally了
 格式：
 A a=new A();
 B b=new B();
 try(a;b){
   可能会产生异常的代码
 }catch(异常类变量 变量名){
   异常处理逻辑
 }

```
//1、创建一个FileInputStream对象。构造方法中绑定要读取的数据源。
 FileInputStream fis=new FileInputStream("F:\\1.png");
 //2、创建一个FileOutputStream对象，构造方法中绑定要写入的目的地。
 FileOutputStream fos=new FileOutputStream("D:\\1.png");
 try(fis;fos){
     //3、使用字节输入流对象的方法read读取文件；
     //一次读取一个字节的方式（速度慢）2526
     int len=0;
     while ((len=fis.read())!=-1){
         //4、使用字节输出流对象的方法write写入目的地文件中；
         fos.write(len);
     }
 }catch(IOException e){
     System.out.println(e);
 }
// fos.write(1); //IOException: Stream Closed  流已经关闭了，不能再使用了
```

 