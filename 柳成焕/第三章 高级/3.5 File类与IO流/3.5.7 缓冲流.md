### 3.5.7 缓冲流

#### 一、缓冲流的原理

​                               

增加一个数组，用于缓冲，提高效率。

 

#### 二、字节缓冲输出流BufferedOutputStream

java.io.BufferedOutputStream extends OutputStream
 BufferedOutputStream字节缓冲输出流
 1、继承父类的共性成员方法：
 void close() 关闭此输出流并释放与此流有关的所有系统资源。
 void flush() 刷新此输出流并强制写出所有缓冲的输出字节。
 void write(byte[] b) 将 b.length 个字节从指定的 byte 数组写入此输出流。
 void write(byte[] b, int off, int len) 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。
 abstract void write(int b) 将指定的字节写入此输出流。

2、构造方法：
 BufferedOutputStream(OutputStream out)
 BufferedOutputStream(OutputStream out, int size)
 参数： 

OutputStream out字节输出流。我们可以传递FileOutputStream，缓冲流会给FileOutputStream增加一个缓冲区，提高FileOutputStream的写入效率。
 int size指定缓冲流内部缓冲区的大小，不指定就是默认大小。
 
 **3****、使用步骤【重点】：**
   1、创建FileOutputStream对象，构造方法中绑定要输出的目的地；
   2、创建BufferedOutputStream对象，构造方法中传递FileOutputStream对象，提高FileOutputStream对象效率；
   3、使用BufferedOutputStream对象中的write将数据写入内部缓冲区中；
   4、使用BufferedOutputStream对象中的flush方法把内部缓冲区的数据，刷新到文件中；
   5、释放资源（会先调用flush方法刷新数据，第四步可以省略）**关闭缓冲流会一起将基本流关闭。**

 

```
FileOutputStream fos=new FileOutputStream("IO0728\\a.txt");
BufferedOutputStream bos=new BufferedOutputStream(fos);
bos.write("我把数据写入到内部缓冲区中".getBytes());
bos.flush();
bos.close();
```

 

#### 三、BufferedInputStream字节缓冲输入流

java.io.BufferedInputStream extends InputStream
 BufferedInputStream字节缓冲输入流
 1、继承父类的共性成员方法
 int read() 从输入流中读取数据的下一个字节。
 int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。
 void close() 关闭此输入流并释放与该流关联的所有系统资源。
 
 2、构造方法
 BufferedInputStream(InputStream in)
 BufferedInputStream(InputStream in, int size)
 参数：
 InputStream in字节输入流，我们可以传递FileInputStream,缓冲流会给FileInputStream增加一个缓冲区，提高FileInputStream的读取效率。
 int size指定缓冲流内部缓冲区的大小，不指定就是默认大小。
 
 3、使用步骤
 （1）创建一个InputStream对象，构造方法中绑定要读取的数据源；
 （2）创建BufferedInputStream对象，构造方法中传递InputStream对象，提高其读取效率；
 （3）使用BufferedInputStream对象中的read方法，读取文件；
 （4）释放资源。

```
FileInputStream fis = new FileInputStream("IO0728\\a.txt");
BufferedInputStream bis = new BufferedInputStream(fis);
/*int len=0;//记录每次读取到的字节,一次读一个字节
while ((len=bis.read())!=-1){
    System.out.println(len);
}*/
int len = 0; //记录每次读取的有效字节数
byte[] bytes = new byte[1024];
while ((len=bis.read(bytes))!=-1){
    System.out.println(new String(bytes));
}

bis.close();
```

 

#### 四、缓冲流的效率测试

文件复制练习：一读一写
 明确：
   数据源：f:\\1.png
   数据目的地：d:\\1.jpg
 文件复制的步骤：
 1、创建字节缓冲输入流，构造方法中传递字节输入流；
 2、创建字节缓冲输出流，构造方法中传递字节输出流；
 3、使用字节缓冲输入流对象的read方法，读取文件；
 4、使用字节缓冲输出流对象的write方法，把写出到内存缓冲区；
 5、释放资源

```
//获取开始毫秒值
 long start = System.currentTimeMillis();
 //1、创建字节缓冲输入流，构造方法中传递字节输入流；
 BufferedInputStream bis = new BufferedInputStream(new FileInputStream("f:\\1.png"));
 //2、创建字节缓冲输出流，构造方法中传递字节输出流；
 BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("d:\\1.png"));
 //3、使用字节缓冲输入流对象的read方法，读取文件；

 /*一次读取一个字节  20毫秒*/
 int len = 0;
 while ((len = bis.read()) != 0) {
     bos.write(len);
 }

 /*一次读取多个字节  4毫秒*/
/* int len = 0;
 byte[] bytes = new byte[1024];
 while ((len=bis.read(bytes))!=-1){
     bos.write(bytes,0,len);
 }*/
 bis.close();
 bos.close();
 //获取结束毫秒值
 long end = System.currentTimeMillis();
 System.out.println(end - start);
```

 

#### 五、字符缓冲输出流BufferedWriter

java.io.BufferedWriter extends Writer
 BufferedWriter字符缓冲输出流
 1、继承自父类的共性成员方法
 abstract void close() 关闭此流，但要先刷新它。
 void flush() 刷新该流的缓冲。
 void write(char[] cbuf) 写入字符数组。
 void write(char[] cbuf, int off, int len) 写入字符数组的某一部分。
 void write(int c) 写入单个字符。
 void write(String str) 写入字符串。
 void write(String str, int off, int len) 写入字符串的某一部分。
 
 2、构造方法
 BufferedWriter(Writer out)
 BufferedWriter(Writer out, int sz)
 参数：Writer out字符输出流，我们可以传递FileWriter，缓冲流会给FileWriter增加一个缓冲区，提高FileWriter的写入效率
   int sz定缓冲流内部缓冲区的大小，不指定就是默认大小。
 
 3、特有的成员方法
 void newLine() 写入一个行分隔符。 会根据不同的操作系统，获取不同的行分隔符。
 
 4、使用步骤
 （1）创建一个字符缓冲输出流对象，构造方法传递字符输出流对象；
 （2）调用字符缓冲输出流对象的write方法将数据写到缓冲区中；
 （3）调用字符缓冲输出流对象的flush方法,把内存缓冲区中的数据刷新到内存；
 （4）释放资源。

```
BufferedWriter bw=new BufferedWriter(new FileWriter("IO0728\\b.txt"));
for (int i = 0; i < 10; i++) {
    bw.write("你好呀"+i);
    //bw.write("\r\n");
    bw.newLine();
}
bw.flush();
bw.close();
```

 

#### 六、字符缓冲输入流BufferedReader

java.io.BufferedReader extends Reader
 BufferedReader字符缓冲输入流
 1、继承自父类的共性成员方法
 int read() 读取单个字符并返回。
 int read(char[] cbuf) 一次读取多个字符，存入数组
 void close() 释放资源
 
 2、构造方法
 BufferedReader(Reader in)传递字符输入流，可以传递FileReader
 BufferedReader(Reader in, int sz)
 
 3、特有的成员方法
 String readLine() 读取一行数据。行的终止符号：换行 ('\n')、回车 ('\r') 或回车后直接跟着换行（\r\n）。
 返回值：包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null
 
 4、使用步骤
 （1）创建一个字符缓冲输入流对象，构造方法传递字符输入流；
 （2）使用字符缓冲输入流对象的read/readLine方法读取文本；
 （3）释放资源。

```
BufferedReader br=new BufferedReader(new FileReader("IO0728\\b.txt"));
String line=null;
while ((line=br.readLine())!=null){
    System.out.println(line);
}
br.close();
```

 

#### 七、练习：文本排序IO0728/demo05Test

练习：对文本的内容进行排序。按照文本的序号进行段落排序。
 分析：
 1、创建一个HashMap集合。k存储文本中的序号，value存储段落内容，String类型。
 2、创建一个字符缓冲输入流对象，读取文本
 3、HashMap会对序号进行自动排序
 4、遍历集合，获取键值，拼接值一个字符串。
 4、再将排序完的文本，使用字符缓冲输出流存至文件中。

```
HashMap<String, String> map = new HashMap<>();
BufferedReader br = new BufferedReader(new FileReader("IO0728\\a.txt"));
BufferedWriter bw=new BufferedWriter(new FileWriter("IO0728\\c.txt"));
String line = null;
while ((line = br.readLine()) != null) {
    //文本切割
    String[] arr = line.split("、");
    map.put(arr[0], arr[1]);
}
//遍历
Set<String> set = map.keySet();
for (String key : set) {
    String value = map.get(key);
    //拼接键值
    String text = key +"、"+ value;
    //将其写入到文件中
    bw.write(text);
    bw.newLine();
}
br.close();
bw.close();
```

 