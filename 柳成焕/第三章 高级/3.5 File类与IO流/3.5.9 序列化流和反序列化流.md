### 3.5.9 序列化流和反序列化流

#### 一、概述

Person p=new Person(“啊柳”,18);

把对象以流的方式，写入到文件中保存，叫做写对象，也叫作**对象的序列化**。

对象中包含的不仅仅是字符，还有字节流。

ObjectOutputStream对象的序列化流

WriterObject(p);

把文件中保存的对象以流的方式读取出来，叫做读对象，也叫**对象的反序列化**。

读取文件保存的都是字节，会用字节流。

ObjectInputStream对象的反序列化流

readObject();

用Object接收

​                               

#### 二、对象的序列化ObjectOutputStream

java.io.ObjectOutputStream extends OutputStream
 ObjectOutputStream对象的序列化流，把对象以流的方式写入到文件中保存。
 
 （一）构造方法
 ObjectOutputStream(OutputStream out) 创建写入指定字节输出流 OutputStream 的 ObjectOutputStream。
 
 （二）特有的成员方法
 void writeObject(Object obj) 将指定的对象写入 ObjectOutputStream。
 
 （三）使用步骤
 1、创建ObjectOutputStream对象，构造方法中传递字节输出流；
 2、使用ObjectOutputStream对象的writeObject方法把对象写入到文件中；
 3、资源释放。

 

（四）注意

```
序列化和反序列化时，会抛出NotSerializableException没有序列化异常
Serializable接口也叫作标记型接口，要进行序列化和反序列化的类，必须实现Serializable接口，给类添加一个标记。
当我们进行序列化和反序列化时，就会检测类上是否有这个标记：
有：可以进行序列化和反序列化
没有：就会抛出NotSerializableException异常
public class Person implements Serializable {…}
去市场卖肉-->肉上有一个蓝色章（检测合格）-->放心购买-->买回来怎么吃随意
ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("IO0728\\person.txt"));
oos.writeObject(new Person("芈月",18));
oos.close();
```

 

#### 三、对象的反序列化流ObjectInputStream

```
ObjectInputStream对象的反序列化流，把文件中保存的额对象，以流的形式读取出来使用

（一）构造方法
ObjectInputStream(InputStream in) 创建从指定 字节输入流InputStream 读取的 ObjectInputStream。

（二）特有的成员方法
Object readObject() 从 ObjectInputStream 读取对象

（三）使用步骤
1、创建ObjectInputStream对象，构造方法中传递字节输入流；
2、使用ObjectInputStream对象的方法readObject读取保存对象的文件；
3、释放资源。
4、使用读取出来的对象（打印）。

readObject方法声明抛出了ClassNotFoundException（class文件找不到异常）
当不存在对象的class文件时，抛出此异常
反序列化的前提：
1、类必须实现Serializable接口；
2、必须存在类对象的class文件。
public static void main(String[] args) throws IOException, ClassNotFoundException {
    ObjectInputStream ois = new ObjectInputStream(new FileInputStream("IO0728\\person.txt"));
    Object obj = ois.readObject();
    ois.close();
    System.out.println(obj);
    //转换为Person类型
    Person p = (Person) obj;
    System.out.println(p);
}
```

 

#### 四、transient关键字

**static****静态关键字**：
 1、静态优先于非静态加载到内存中（静态优先于对象进入到内存中）
 2、被static修饰的成员变量不能被序列化，序列化的都是对象
 private static int age;
 oos.writeObject(new Person("芈月",18));
 System.out.println(obj);//Person{name='芈月', age=0}
 
 **transient****关键字**：瞬态关键字
 被transient关键字修饰的成员变量，不能被序列化
 private transient int age;
 oos.writeObject(new Person("芈月",18));
 System.out.println(obj);//Person{name='芈月', age=0}

 

#### 五、InvalidClassException异常

**问题**：每次修改类的定义，都会给class生成一个新的序列号，这个序列号在反序列化时会与txt文件中序列号进行对比。如果不一样，就会抛出InvalidClassException异常。

 

**解决**：无论是否对类的定义进行修改，都不重新生成新的序列号，可以手动给类添加一个序列号。可序列化类可以通过声明名为 "serialVersionUID" 的字段（该字段必须是静态 (static)、最终 (final) 的 long 型字段）显式声明其自己的 serialVersionUID： 

*private static final long serialVersionUID=42L;*

 

 

 

#### 六、练习：序列化集合

练习：当我们想在按文件中保存多个对象的时候，可以把多个对象存储到一个集合中面对集合进行序列化和反序列化。
 分析：
 1、定义一个存储Person对象的ArrayList集合，add多个对象
 2、定义一个序列化流对象，
 3、定义一个反序列化流对象
 4、使用序列化对象的writeObject()将集合写入
 5、使用反序列化的readObject（）将集合取出
 6、将Object转为ArrayList集合,遍历
 7、释放资源

```
public static void main(String[] args) throws IOException, ClassNotFoundException {
    ArrayList<Person> list = new ArrayList<>();
    list.add(new Person("芈月", 17));
    list.add(new Person("王昭君", 18));
    list.add(new Person("孙尚香", 19));

    ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("IO0728\\list.txt"));
    //序列化集合
    oos.writeObject(list);
    //反序列化
    ObjectInputStream ois = new ObjectInputStream(new FileInputStream("IO0728\\list.txt"));
    Object obj = ois.readObject();
    //将OBJ转为ArrayList集合
    ArrayList<Person>list02=(ArrayList<Person>)obj;
    for (Person person : list02) {
        System.out.println(person);
    }
    //释放资源
    ois.close();
    oos.close();
}
```