### .7.1 常用函数接口

#### 3.7.1.1 函数式接口

**一、函数式接口的概念**

函数式接口：有且只有一个抽象方法的接口当然接口中可以包含其他的方法（默认方法、静态方法、私有方法）à适用于函数式编程场景的接口。Lambda

“语法糖”：使用更加方便，但是原理不变的代码语法。

格式：

修饰符 interface 接口名称{

​    public abstract 返回值类型 方法名称（可选参数信息）;

}
 @Override:检测方法是否为重写的方法
 是：编译成功
 否：编译失败


 注解@FunctionalInterface：检测接口是否是一个函数式接口。
 是：编译成功
 否：编译失败（接口中没有抽象方法；抽象方法的个数不为1个）

**二、函数式接口的使用**

一般可以**作为方法的参数和返回值类型**。

（一）用作方法参数

```
//定义一个方法，参数使用函数式接口
public static void show(MyFunctionalInterface myInter){
    myInter.method();
}
```

调用方法，可使用：接口的实现类对象、接口的匿名内部类、Lambda表达式（简化）

#### 3.7.1.2 函数式编程

**一、日志案例**

日志案例：根据日志级别，显示日志

**（一）性能浪费的日志案例**
 发现以下代码。存在一些性能浪费问题。
 调用showLogger方法，传递的第二个参数是一个拼接后的字符串
 先把字符串拼接好，再调用再调用showLogger方法
 showLogger方法如果传递的日志等级不是1级，那么字符串就白拼接了，存在了浪费

```
//根据日志级别，显示日志
public static void showLogger(int lever, String message) {
    if (lever == 1) {
        System.out.println(message);
    }
}
public static void main(String[] args) {
    //定义三个日志信息
    String message1 = "hello";
    String message2 = "world";
    String message3 = "java";
    showLogger(2, message1 + message2 + message3);
}
```

 

（二）使用lambda优化日志案例
 lambda特点：延迟加载
 lambda使用前提：必须存在函数式接口。
 
 使用lambda表达式作为参数传递，仅仅是把蚕食传递到showLogger方法中
 只有满足条件，日志的等级是1级，才会调用MessageBuilder中的方法builderMessage，才会进行字符串的额拼接。
 如果条件不满足，日志的等级不是1级，那么调用MessageBuilder中的方法builderMessage就不会执行，所以拼接字符串的代码也不会执行，所以不会存在性能的浪费。

```
public static void main(String[] args) {
    //定义三个日志信息
    String message1 = "hello";
    String message2 = "world";
    String message3 = "java";
    //调用方法builderMessage，参数是函数是接口，所以可以传递lambda表达式
    showLogger(1,()->{
        System.out.println("不满足条件不执行");
        //返回一个拼接好的字符串
        return message1+message2+message3;
    });
}
```

 

**二、函数式接口作为方法参数**

java.lang.Runnable接口就是一个函数式接口，假设有一个startThread方法作为参数，那么就可以使用Lambda进行传参、
 这种抢矿其实和Thread类的构造方法参数为Runnable没有本质区别。

```
public static void startThread(Runnable r){
    //开启多线程
    new Thread(r).start();
}
public static void main(String[] args) {
    //调用startThread方法，方法参数是一个接口，那我们可以传递这个接口的匿名内部类
    startThread(new Runnable() {
        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName()+"-->线程启动了");
        }
    });

    //调用startThread方法，方法参数是一个接口，那我们可以传递Lambda表达式
    startThread(()->{
        System.out.println(Thread.currentThread().getName()+"-->线程启动了");
    });

    //优化Lambda
    startThread(()-> System.out.println(Thread.currentThread().getName()+"-->线程启动了"));
}
```

 

**三、函数式接口作为方法返回值**

如果一个方法的返回值类型是一个函数式接口，那么就可以直接返回一个lambda表达式。
 当需要通过一个方法来获取一个java.util.Comparator接口类型的对象作为排序器时，就可以调用该方法。

```
//定义一个方法，返回值类型使用函数式接口Comparator
public static Comparator<String> getComparator() {
    //方法的返回值类型是一个接口，那我们可以返回这个接口的匿名内部类
    /*return new Comparator<String>() {
        @Override
        public int compare(String o1, String o2) {
            //按照字符串的顺序排序
            return o1.length()-o2.length();
        }
    };*/

    //方法的返回值类型是一个接口，那我们可以返回一个lambda表达式
    /*return (String o1,String o2)->{
        return o1.length()-o2.length();
    };*/

    //优化lambda
    return (o1, o2) -> o1.length() - o2.length();
}

public static void main(String[] args) {
    String []s = {"12345" ,"123","1234"};
    System.out.println("排序前：");
    System.out.println(Arrays.toString(s));
    //调用arrays的sort方法对字符串数组排序
    Arrays.sort(s,getComparator());
    System.out.println("排序后：");
    System.out.println(Arrays.toString(s));
}
```

 

#### 3.7.1.3 常用的函数式接口

##### 一、Supplier接口

（一）java.util.function.Supplier<T>接口仅包含一个无参的方法：T get();用来获取一个泛型参数指定类型的对象数据。
 Supplier<T>接口被称之为生产型接口，指定接口的泛型是什么类型，那么接口中的get方法就会生产什么类型的数据。

```
//定义一个方法，参数传递Supplier<T>接口，泛型执行String.get方法，就会返回一个String
public static String getString(Supplier<String> sup) {
    return sup.get();
}

public static void main(String[] args) {
    //调用getString方法，方法的参数Supplier是一个函数式接口，可以传递lambda表达式
  /*  String s=getString(() -> {
        //生产一个字符串并返回
        return "hello";
    });*/
    //优化lambda 生产一个字符串并返回
    String s=getString(() ->  "hello");
    System.out.println(s);
}
```

 

**（二）练习：求数组元素最大值。**

求int数组元素最大值。使用Supplier接口作为方法参数，通过lambda表达式楸树int数组中的最大值。

```
//定义一个方法，用于获取数组的最大值，方法参数传递Supplier接口，泛型使用Integer
public static int getMax(Supplier<Integer> sup) {
    return sup.get();
}
public static void main(String[] args) {
    int[] arr = {3, 5, 3, 7, 2, 7, 10, 1, 3, 4};
    //调用getMax方法，参数为函数式接口，可以传递lambda表达式
    int num = getMax(() -> {
        //获取数组的最大值，并返回
        //定义一个变量，将数组第一个元素赋值给该变量，记录元素中的最大值
        int max = arr[0];
        //遍历数组。获取数组中其他元素
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        return max;
    });
    System.out.println("最大值为：" + num);
}
```

 

##### 二、Consumer接口

（一）概念：

Comsumer<T>接口正好与Supplier接口与相反，Consumer接口是一个消费型接口，泛型指定什么类型，就可以使用accept方法消费什么类型的数据。
 至于怎么消费（使用）数据，需要自定义（输出，计算等）

```
//定义一个方法，参数传递字符串的姓名，参数传递Consumer接口消费字符串的姓名
public static void method(String name, Consumer<String> com) {
    com.accept(name);
}
public static void main(String[] args) {
    method("孙尚香", (String name) -> {
        //对传递的字符串进行消费
        //消费方式1：直接输出字符串
        System.out.println(name);
        //消费方式2：把字符串进行反转输出
        String reName = new StringBuffer(name).reverse().toString();
        System.out.println(reName);
    });
}
```

**（二）默认方法：andThen**

作用：需要两个Consumer接口，可以把两个Consumer接口组合在一起，再对数据进行消费。
 例如
 Consumer<String>con1
 Consumer<String>con2
 String s="hello";
 com1.accept(s);
 com2.accept(s);
 
 用andThen优化：连接两个Consumer接口，再进行消费
 con1.andThen(con2).accept(s);谁写前边，谁先进行消费

```
//定义一个方法，参数传递一个字符串和两个Consumer接口，Consumer接口的泛型使用Sting
    public static void method(String s, Consumer<String> con1, Consumer<String> con2) {
       /* con1.accept(s);
        con2.accept(s);*/
        //使用andThen方法优化  与上面等同
        con1.andThen(con2).accept(s);  //con1先消费，con2后消费
    }
    public static void main(String[] args) {
        //调用method方法，传递一个字符串，两个lambda表达式
        method("hello",
                (String s) -> {
                    //con1的消费方式：转换为大写输出
                    System.out.println(s.toUpperCase());
                },
                (String s) -> {
                    //con2的消费方式，反转
                    String name=new StringBuffer(s).reverse().toString();
                    System.out.println(name);
                });
    }
}
```

 

**（三）格式化打印输出**

​                               

```
//定义一个方法，参数传递String类型数组和2个Consumer接口
public static void printInfor(String[] arr, Consumer<String> con1, Consumer<String> con2) {
    //遍历字符串数组
    for (String s : arr) {
        //使用andThen方法连接两个Consumer接口，消费字符串
        con1.andThen(con2).accept(s);
    }
}
public static void main(String[] args) {
    //定义一个字符串类型的数组
    String[] arr = {"王昭君,女", "孙尚香, 女", "庄周, 男"};
    printInfor(arr,
            (String s) -> {
                //消费方式：对s进行切割，获取姓名，按照指定格式输出
                String name = s.split(",")[0];
                System.out.print("姓名：" + name);
            },
            (String s) -> {
                String male = s.split(",")[1];
                System.out.println("。性别：" + male+"。");
            });
}
```

 

##### 三、Predicate接口

Predicate<T>接口：
 作用：对某种数据类型进行判断，从而得到一个boolean值。
 **（一）抽象方法：boolean test(T t):**用来对指定数据类型的数据进行判断的方法
 结果：符合条件，true;不符合条件：false。

```
//定义一个方法，传递String字符串，1个Predicate接口，使用test方法对字符串进行判断，并将结果返回
public static boolean check(String s, Predicate<String> prep) {
    return prep.test(s);
}
public static void main(String[] args) {
    String s = "hello1";
    /*boolean b = check(s, (String str) -> {
        //对参数传递的字符串进行判断，判断字符串的长度是否大于5
        return str.length()>5;
    });*/
    //优化lambda表达式
    boolean b = check(s, (str) -> str.length()>5);
        //对参数传递的字符串进行判断，判断字符串的长度是否大于5
    System.out.println(b);
}
```

**（二）默认方法and**

逻辑表达式：可以连接多个判断条件
 &&：与，有false则false
 ||：或，有true则true
 !：非
 
 需求：判断一个字符串，有两个判断的条件
 1、字符串的长度是否大于5
 2、字符串中是否包含a
 要求两个条件必须同时满足，就可以使用&&运算符连接两个条件。
 
 Predicate接口中有一个方法and，表示并且关系，也可以用于连接两个判断条件。
 方法内部的两个判断条件也是使用&&运算符连接起来的。

```
//定义一个方法，传递1个字符串，传递2个Predicate接口，一个用于判断字符串长度，一个用于判断是否包含a
//两个条件必须同时满足
public static boolean checkString(String s, Predicate<String> prep1, Predicate<String> prep2) {
    //return prep1.test(s) && prep2.test(s);
    return prep1.and(prep2).test(s); //与上一行等价
}
public static void main(String[] args) {
    String s = "abcdef";
   /* boolean b = checkString(s,
            (String str) -> {
                //字符串的长度是否大于5
                return str.length() > 5;
            },
            (String str) -> {
                //字符串中是否包含a
                return str.contains("a");
            });*/
    //简化lambda
    boolean b = checkString(s, (str) -> str.length() > 5, (str) -> str.contains("a"));
    System.out.println(b);
}
```

 

**（三）默认方法or**

需求：判断一个字符串，有两个判断的条件
 1、字符串的长度是否大于5
 2、字符串中是否包含a
 要求满足一个条件即可，就可以使用||运算符连接两个条件。
 
 Predicate接口中有一个方法or，表示或关系，也可以用于连接两个判断条件。
 方法内部的两个判断条件也是使用||运算符连接起来的。

```
//return prep1.test(s) || prep2.test(s);
return prep1.or(prep2).test(s); //与上一行等价
```

 

**（四）默认方法negate**

```
需求：判断一个字符串，字符串的长度是否大于5
大于5，返回false;不大于5，返回true
所以我们可以使用取反符号对判断结果进行取反
Predicate接口中有一个方法negate，表示取反。
//定义一个方法，传递1个字符串，传递1个Predicate接口，一个用于判断字符串长度
//满足一个条件即可
public static boolean checkString(String s, Predicate<String> prep) {
    //return !(prep.test(s));
    return prep.negate().test(s);
}
public static void main(String[] args) {
    String s = "defg";
    boolean b = checkString(s,
            (String str) -> {
                //字符串的长度是否大于5
                return str.length() > 5; //这里为什么不需要取反呢？？
            });
    System.out.println(b);
}
```

 

**（四）练习：集合信息筛选**

 

1、有两个判断条件，所以需要使用两个Predicate接口
 2、必须同时满足两个条件，可以使用and方法连接两个判断条件

```
//定义一个方法，参数传递数组，2个Predicate接口，用于对数组信息进行过滤
//把满足条件的信息存到ArrayList集合中保存并返回
public static ArrayList<String> check(String[] arr, Predicate<String> pre1, Predicate<String> pre2) {
    //创建ArrayList用于存储过滤之后的信息
    ArrayList<String> list = new ArrayList<>();
    //遍历数组，获取每一条信息
    for (String s : arr) {
        //对字符串进行判断
        boolean b = pre1.and(pre2).test(s);
        if (b) {
            //两个条件都满足则把信息存储到ArrayList中
            list.add(s);
        }
    }
    return list;
}
public static void main(String[] args) {
    //定义一个字符串类型的数组
    String[] arr = {"王昭君,女","孙尚香,女","庄周,男"};
    //调用方法
    ArrayList<String> list = check(arr,
            (String s) -> {
                //获取自字符串中的姓名，判断长度是否为2
                int length = s.split(",")[0].length();
                return ( length== 2);
            },
            (String s) -> {
                //获取字符串的性别，判断是否为男
                String male=s.split(",")[1];
                return male.equals("男");
            });
    //遍历集合输出
    for (String s : list) {
        System.out.println(s);
    }
}
```

 

##### 四、Function接口

（一）基本使用

java.util.function.Function<T,R>接口，用来根据一个类型的数据，得到另一个类型的数据。
 前者称为前置条件，后者称为后置条件。
 Function接口中最主要的抽象方法为R apply(T t),根据T的参数获取R类型的参数。
 使用场景如：String类型转为Integer类型。

```
/*定义一个方法，传递1个字符串类型的整数，1个Function类型的接口
使用Function接口中的apply，把字符串转为integer*/
public static void change(String s, Function<String, Integer> fun) {
    //Integer in = fun.apply(s);
    int in = fun.apply(s);//自动拆箱
    System.out.println(in);
}
public static void main(String[] args) {
    String s = "123";
    /*change(s,(String str)->{
        //把字符串转为Integer整数输出
        return Integer.parseInt(str);
    });*/
    //简化lambda
    change(s, (str) -> Integer.parseInt(str));
}
```

 

**（二）默认方法andThen**

Function接口中的默认方法andThen：用来进行组合操作。
 需求：
 把String类型的“123”Integer类型，再把转换后的结果加10
 把增加之后的Integer类型的数据，转换为String类型。
 
 分析：一共转换了两次，
 1、第一次是把String类型转为Integer类型，可用Function<String,Integer>
 Integer in=fun1..apply("123")+10
 2、第二次是把Integer类型转为String类型，Function<Integer,String>
 String s=fun2.apply(in);
 
 我们可以使用andThen方法，把两次转换组合在一起，
 String s=fun1.andTen(fun2).apply("123");
 执行顺序：fun1先调用apply将字符串转为Integer类型，fun2再调用apply将Integer类型转为String。

 

```
public static void change(String s, Function<String, Integer> fun1, Function<Integer, String> fun2) {
    s = fun1.andThen(fun2).apply(s);
    System.out.println(s);
}
public static void main(String[] args) {
    String s = "123";
    /*change(s, (String str) -> {
                //把String类型的“123”Integer类型，再把转换后的结果加10
                return Integer.parseInt(str) + 10;
            },
            (Integer in) -> {
                //第二次是把Integer类型转为String类型，Function<Integer,String>
                return (in + "");
            });*/
    //优化lambda
    change(s, (str) ->  Integer.parseInt(str) + 10 , (in) -> in + "");
}
```

 

**（三）自定义函数模型拼接**

 

```
分析：
1、Function<String,String>  "孙尚香,20"  -->"20"
2、Function<String,Integer>  "20"     -->  20
3、Function<Integer,Integer>  20   -->120
 */
public class Demo03Test {
    //定义一个方法，传递一个字符串，3个Function接口
    public static void method(String s, Function<String, String> fun1, Function<String, Integer> fun2, Function<Integer, Integer> fun3) {
        Integer age = fun1.andThen(fun2).andThen(fun3).apply(s);
        System.out.println(age);
    }

    public static void main(String[] args) {
        String s = "孙尚香,20";
       /* method(s,
                (String str1) -> {
                    return str1.split(",")[1];
                },
                (String str2) -> {
                    return Integer.parseInt(str2);
                },
                (Integer in) -> {
                    return in + 100;
                });*/
        //简化lambda
        method(s, (str1) -> str1.split(",")[1], (str2) -> Integer.parseInt(str2), (in) -> in + 100);
    }
```

 