### 3.7.2 Stream流

#### 一、使用Stream流的方式，遍历集合，对集合中的数据进行过滤。

Stream流是JDK1.8之后出现的，关注的是做什么，而不是怎么做。

```
//遍历元素，将以“张”开头的元素，存储到新集合中
//遍历元素,只要姓名长度为3的人
//遍历元素,打印输出
list.stream()
        .filter(name -> name.startsWith("张"))
        .filter(name -> name.length() == 3)
        .forEach(name -> System.out.println(name));
```

#### 二、流式思想概述

拼接流式模型：建立一个生产线，按照生产线，来生产物品。

生产饮料：放瓶子→洗瓶子→装饮料→封口→装箱

​                               

 

 

#### 三、两种获取Stream流的方式

java.util.stream.Stream<T>是Java8新加入的最常用的接口。（这并不是一个函数式接口）
 获取一个流非常简单，主要有以下方式。
 1、所有的Collection集合都可以通过**stream****默认方法**获取流；
 default stream<E> stream()

```
//把集合转换为Stream流
List<String> list = new ArrayList<>();
Stream<String> stream1 = list.stream();
Map<String, String> map = new HashMap<>();
//获取键，把键存储到set集合中
Set<String> keySet = map.keySet();
Stream<String> stream3 = keySet.stream();
//获取值，存储到Collection集合中
Collection<String> values = map.values();
Stream<String> stream4 = values.stream();
//获取键值对，（键与值的映射关系entrySet）
Set<Map.Entry<String, String>> entries = map.entrySet();
Stream<Map.Entry<String, String>> stream5 = entries.stream();
```


 2、Stream接口的**静态方法****of**可以获取数组对象的流。
 static <T> Stream<T> of(T...value)
 参数是一个可变参数，那我们可以传递一个数组。

```
//把数组转为Stream流
Stream<Integer> stream6 = Stream.of(1, 2, 3, 4, 5);
//可变参数可以传递数组
Integer[] arr1 = {1, 2, 3, 4, 5};
Stream<Integer> stream7 = Stream.of(arr1);
String[] arr2 = {"aaa", "bbbb", "cccc"};
Stream<String> stream8 = Stream.of(arr2);
```

 

#### 四、Stream流中的常用方法

（一）延迟方法：返回值类型依然是Stream接口自身类型的方法，因此支持链式调用。

（二）终结方法：返回值类型不再是Stream接口自身类型的方法。count,foreach

**1****、Stream****流中的常用方法foreach**
 void forEach​(Consumer<? super T> action):该方法接收一个Consumer接口函数，会将每一个流元素交给函数进行处理。
 Consumer接口是一个消费型的函数式接口，可以传递lambda表达式，消费数据。
 简单记：**forEach****方法，用来遍历流中的数据，是一个终结方法，遍历后就不能继续调用Stream****流的其他方法。**

```
//获取一个Stream流
 Stream<String> stream = Stream.of("王昭君", "孙尚香", "芈月", "庄周");
 //使用forEach方法遍历流中的数据
/* stream.forEach((String name) -> {
     System.out.println(name);
 });*/
 stream.forEach((name) -> System.out.println(name));
```

 

**2****、****Stream****常用方法****filter****：用于对数据进行过滤**
 Stream<T> filter​(Predicate<? super T> predicate)
 参数是一个函数式接口Predicate，所以可以传递lambda表达式，对数据进行过滤。
 Predicate中的抽象方法：boolean test(T t)

```
//创建一个Stream流
Stream<String> stream01 = Stream.of("凯", "庄周", "阿珂", "王昭君", "芈月", "张飞", "张无忌");
//对流中的元素进行过滤,只要姓张的
Stream<String> stream02 = stream01.filter((String name) -> {
    return name.startsWith("张");
});
//遍历集合输出
stream02.forEach((name) -> System.out.println(name));
```

 

**3****、****Stream****流常用方法****map:****将流中的元素映射到另一个流中。**
 <R> Stream<R> map​(Function<? super T,? extends R> mapper)
 该接口需要一个Function函数式接口，可以将当前的T类型转为R类型。
 Function中抽象方法：R apply(T t);

```
//获取一个流
Stream<String> stream1 = Stream.of("111", "222", "333", "444");
//使用map方法将字符串类型整数映射为Integer类型的整数
Stream<Integer> stream2 = stream1.map((String s) -> {
    return Integer.parseInt(s);
});
//遍历输出stream2
stream2.forEach((in)-> System.out.println(in));
```

 

**4****、****count****方法：用于统计****Stream****流中元素个数：**
 long count​()； 是一个终结方法，返回值是long类型的整数，所以不能再继续调用Stream中的其他方法了。

```
//获取一个Stream流
List<Integer> list = new ArrayList<>();
list.add(11);
list.add(22);
list.add(33);
list.add(44);
list.add(55);
Stream<Integer> stream = list.stream();
long count = stream.count();
System.out.println(count);  //5
```

 

**5****、****limit****方法：用于截取流中的元素。**
 对流进行截取，只取用前n个。
 Stream<T> limit​(long maxSize) 参数是一个long型，如果集合当前长度大于参数则进行截取，否则不进行操作。
 是一个延迟方法，只是对流中的元素进行截取，返回的是一个新的流，所以可以继续调用Stream流中其他方法。

```
//获取Stream流
String[] arr = {"喜羊羊", "懒羊羊", "红太狼", "灰太狼"};
Stream<String> stream = Stream.of(arr);
//使用limit方法对流进行截取，只要前两个元素
Stream<String> stream2 = stream.limit(2);
//遍历stream2
stream2.forEach((s -> System.out.println(s))); //喜羊羊  懒羊羊
```

 

**6****、****skip****：用于跳过前几个元素。**
 如果希望跳过几个元素，可以使用skip方法获取一个截取后的新流。
 Stream<T> skip​(long n)
 如果流的当前长度大于n,则跳过前n个；否则会得到一个长度为0的空流。

```
//获取Stream流
String[] arr = {"喜羊羊", "懒羊羊", "红太狼", "灰太狼"};
Stream<String> stream = Stream.of(arr);
//使用skip方法跳过前2个元素
Stream<String> stream2 = stream.skip(2);
//遍历stream2
stream2.forEach((s -> System.out.println(s))); //红太狼 灰太狼
```

 

**7****、****concat****方法：用于把流组合到一起。**
 如果有两个流，希望合并为一个流，那么就可以使用Stream接口的静态方法concat。
 static <T> Stream<T> concat​(Stream<? extends T> a, Stream<? extends T> b)

```
//创建2个Stream流
Stream<String> stream01 = Stream.of("王昭君", "芈月", "张飞", "张无忌");
String[] arr = {"喜羊羊", "懒羊羊", "红太狼", "灰太狼"};
Stream<String> stream02 = Stream.of(arr);
//把以上两个流组合为一个流
Stream<String> concat = Stream.concat(stream01, stream02);
//遍历concat流
concat.forEach((s)-> System.out.println(s));
```

 

#### 五、Stream的特点

Stream流属于管道流，**只能被消费（使用）一次**
 第一个Stream流调用完毕后，数据就会流转到下一个Stream流上。
 而这时第一个Stream流已经使用完毕，就会关闭了，所以第一个Stream流不能再调用方法了。
 IllegalStateException: stream has already been operated upon or closed

 

#### 六、练习

 

（一）传统方式

（二）Stream流的方式

```
//第一支队伍
ArrayList<String> one = new ArrayList<>();
one.add("迪丽热巴");
one.add("万茜");
one.add("李斯丹妮");
one.add("张萌");
one.add("张含韵");
one.add("王菲菲");
one.add("蓝盈盈");
one.add("王丽坤");
one.add("孟佳");
one.add("金晨");
//1.第一个队伍只要名字为3个字的成员姓名，存储到一个新的集合中
//2.筛选之后只要前三个元素，存储到一个新的集合中
Stream<String> oneStream = one.stream().filter(name -> name.length() == 3).limit(3);
//第二支队伍
ArrayList<String> two = new ArrayList<>();
two.add("孙尚香");
two.add("王昭君");
two.add("张三");
two.add("庄周");
two.add("张无忌");
two.add("张飞");
two.add("小乔");
two.add("张三丰");
//3.姓张的成员姓名,存储到一个新的集合中
//4.筛选后的集合，不要前两个人，存储到新的集合中
Stream<String> twoStream = two.stream().filter(name -> name.startsWith("张")).skip(2);
//5.将两个筛选后的队伍合并，存储到一个新的集合中
//6.根据姓名创建Person对象，存储到集合中
//7.打印整个队伍信息
Stream.concat(oneStream, twoStream).map(name -> new Person(name)).forEach(person -> System.out.println(person));
```

 