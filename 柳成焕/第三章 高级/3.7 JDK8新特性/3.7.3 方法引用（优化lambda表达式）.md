### 3.7.3 方法引用（优化lambda表达式）

#### 一、通过对象名引用成员方法：

使用前提：对象名是已经存在的，成员方法也是已经存在的，就可以使用对象名来引用成员方法。

```
//定义一个方法，方法的参数传递Printable接口
public static void printString(Printable p) {
    p.print("helloWorld!");
}
public static void main(String[] args) {
    //调用printString函数，参数传递lambda表达式
    printString((s) -> {
        //创建MethodRefObject对象
        MethodRefObject obj = new MethodRefObject();
        //调用MethodRefObject对象中的成员方法,把字符串按照大写输出
        obj.printUpperCaseString(s);
    });
    //使用方法引用优化lambda
    //对象是已经存在的，成员方法也是已经存在的
    //所以可以使用  对象名引用成员方法
    //创建MethodRefObject对象
    MethodRefObject obj = new MethodRefObject();
    printString(obj::printUpperCaseString);
}
```

####  二、通过类名称引用静态成员方法：

使用前提：类已经存在，静态成员方法也已经存在，就可以使用雷鸣层直接引用静态成员方法。

```
//定义一个方法，参数传递要计算绝对值的整数和函数式接口Calcable
public static int method(int num, Calcable c) {
    return c.calAbs(num);
}

public static void main(String[] args) {
    //调用method方法，传递要计算绝对值的整数，和lambda表达式
    int n = method(-10, (int num) -> {
        //计算绝对值并返回
        return Math.abs(num);
    });
    System.out.println(n); //10
    //使用方法引用优化lambda表达式
    //Math类是存在的，abs时候存在的，所以我们可以直接通过类名引用静态方法
    int i = method(-10, Math::abs);
    System.out.println(i); //10
}
```

 

#### 三、通过super引用父类成员方法

 

```
/*定义子类，继承human，重写父类sayHello方法*/
public class Man extends Human {
    @Override
    public void sayHello() {
        System.out.println("hello,我是man!");
    }
    //定义一个方法，参数传递Greetable接口
    public void method(Greetable g){
        g.greet();
    }
    public void show(){
        //调用method方法，参数是函数式接口，可以传递lambda表达式
        method(()->{
            //创建父类Human对象
            Human h=new Human();
            //调用父类的sayHello方法
            h.sayHello();
        });
        /*因为有子父类关系，所以存在一个关键字super代表父类，所以我们可以直接使用super调用父类成员方法*/
        method(()->{
            super.sayHello();
        });
        /*使用super引用父类的成员方法，super是已经存在的，弗雷德额成员方法sayHello也是存在的，
        我们可以直接使用super引用父类的成员方法。     */
        method(super::sayHello);
    }
```

 

#### 四、通过this引用本类的成员方法

```
/*通过this引用本类的成员方法*/
public class Husband {
    //定义买房子的方法
    public void buyHouse(){
        System.out.println("北京二环内买一套四合院！");
    }
    //定义一个结婚的方法,参数传递Richable接口
    public void marry(Richable r){
        r.buy();
    }
    //定义一个非常高兴的方法
    public void soHappy(){
        //调用结婚的方法,方法参数传递lambda表达式
        marry(()->{
            //使用this.成员方法调用本类买房子的方法
            this.buyHouse();
        });
        //使用方法引用优化lambda表达式,this已经存在，本类的成员方法buyHouse也是已经存在的。
        //所以我们可以使用this引用本类的成员方法buyHouse
        marry(this::buyHouse);
    }
    public static void main(String[] args) {
        new Husband().soHappy();
    }
```

 

#### 五、方法引用：类的构造器（构造方法）引用

**类名称::new**

```
//定义一个方法，参数传递姓名和PersonBuilder接口，通过姓名创建Person对象
public static void printName(String name, PersonBuilder pb) {
    Person p = pb.personBuilder(name);
    System.out.println(p.getName());
}
public static void main(String[] args) {
    //调用printName方法。参数传递lambda表达式
    printName("孙尚香", (name) -> {
        return new Person(name);
    });
    //使用方法引用优化lambda，构造方法new Person(String name)已知
    //创建对象已知，new
    //就可以使用Person引用new创建对象
    printName("王昭君", Person::new);  //使用Person类的带参构造方法，通过传递的姓名传递对象
}
```

 

#### 六、数组的构造器引用

*/***定义一个方法，参数传递要创建数组的长度和**ArrayBuilder**接口
 方法内部根据传递的长度使用**ArrayBuilder**中的**arrayBuilder**方法创建数组并返回* **/
\* public static int[] creatArray(int length, ArrayBuilder ab) {
   return ab.arrayBuilder(length);
 }
 public static void main(String[] args) {
   *//**调用**creatArray**方法，传递数组长度和**lambda**表达式
\*   int[] arr1 = *creatArray*(10, (len) -> {
     *//**根据数组长度创建数组并返回
\*     return new int[len];
   });
   System.*out*.println(arr1.length); *//10
   /***使用方法引用优化**lambda**表达式
   已知创建的就是**int**类型的数组，数组的长度也是已知的
   就可以使用方法引用（数组的构造器引用）**
   int[]**引用**new**，根据参数传递的长度来创建数组* **/
\*   int[] arr2 = *creatArray*(5, **int****[]::****new**);
  System.*out*.println(Arrays.*toString*(arr2)); *//[0, 0, 0, 0, 0]
\* }