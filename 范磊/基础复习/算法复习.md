#####1.冒泡排序，两两比较，小浮，大沉

    public void bubbleSort(int[] array) {
        if (array.length == 0 || array == null) {
            return;
        }
        for (int i = 0; i < array.length - 1; i++) {            // 限制总的比价次数
            for (int j = 0; j < array.length - 1 - i; j++) {    // 每次比较的范围，总将最大的放在最后
                if (array[j] > array[j + 1]) {
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
            System.out.println(Arrays.toString(array));
        }

    }

#####2.选择排序 假设一个最小数，每次与后面所有数比较，依次将最小的递推排序

    public void chooseSort(int[] array) {
        if (array == null || array.length == 0) {
            return;
        }

        for (int i = 0; i < array.length - 1; i++) {        // 限制循环次数
            int minIndex = i;                               // 假设当前最小数Index
            for (int j = i+1; j <array.length ; j++) {      // 每次比较都是当前循环的最小数字与后面无序区间比较
                if (array[minIndex] > array[j]) {
                    minIndex = j;                           // 通过比较获取实际最小Index
                }
            }
            int temp = array[minIndex];
            array[minIndex]=array[i];
            array[i] = temp;
            System.out.println(Arrays.toString(array));
        }
    }


#####3.插入排序，从后向前插入，确定一个基数，将其下一位按照大小插入前面的序列中

    public void insertSort(int[] array) {
        if (array == null || array.length == 0) {
            return;
        }
        for (int i = 1; i < array.length; i++) {
            int target = array[i];          // 获取当前比较目标数值
            int j = i;  // j-1是前一位
            while (j > 0 && target <= array[j - 1]) {   // 比较当前位与前一位的大小，如满足条件，则向后替换，并移动j指针
                array[j] = array[j-1];
                j--;
            }
            array[j] = target;  // 此时的j是j--之后的index，不满足上诉条件时跳出，并插入目标值
        }
        System.out.println(Arrays.toString(array));
    }

#####4.快速排序  递归部分，分区部分，值交换部分三部分组成

    public void quickSort(int[] array) {
        if (array == null || array.length == 0) {
            return;
        }
        Sort(array, 0, array.length - 1);
        System.out.println(Arrays.toString(array));

    }

    public void Sort(int[] array,int left,int right) {
        if (left >= right) {
            return;
        }
        int midPos = partition(array, left, right);
        Sort(array, left, midPos - 1);
        Sort(array, midPos + 1, right);

    }

    int[] array = {3, 2, 5, 1, 7, 6, 4};
    public static int partition(int[] array, int left, int right) {
        int pivotValue = array[left];
        int pivotPointer = left;
        while (left < right) {
            // 分别找出左右半区，小于或则大于基数的值的index
            while (left < right && pivotValue <= array[right]) {
                right--;
            }
            while (left < right && pivotValue >= array[left]) {
                left++;
            }
            // 左右区间变换
            int temp = array[left];
            array[left] = array[right];
            array[right] = temp;
        }
        // 将基数转到中间位置
        int temp = array[pivotPointer];
        array[pivotPointer] = array[left];
        array[left] = temp;

        return left;
    }