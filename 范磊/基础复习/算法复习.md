#####1.冒泡排序，两两比较，小浮，大沉

    public void bubbleSort(int[] array) {
        if (array.length == 0 || array == null) {
            return;
        }
        for (int i = 0; i < array.length - 1; i++) {            // 限制总的比价次数
            for (int j = 0; j < array.length - 1 - i; j++) {    // 每次比较的范围，总将最大的放在最后
                if (array[j] > array[j + 1]) {
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
            System.out.println(Arrays.toString(array));
        }

    }

#####2.选择排序 假设一个最小数，每次与后面所有数比较，依次将最小的递推排序

    public void chooseSort(int[] array) {
        if (array == null || array.length == 0) {
            return;
        }

        for (int i = 0; i < array.length - 1; i++) {        // 限制循环次数
            int minIndex = i;                               // 假设当前最小数Index
            for (int j = i+1; j <array.length ; j++) {      // 每次比较都是当前循环的最小数字与后面无序区间比较
                if (array[minIndex] > array[j]) {
                    minIndex = j;                           // 通过比较获取实际最小Index
                }
            }
            int temp = array[minIndex];
            array[minIndex]=array[i];
            array[i] = temp;
            System.out.println(Arrays.toString(array));
        }
    }


#####3.插入排序，从后向前插入，确定一个基数，将其下一位按照大小插入前面的序列中

    public void insertSort(int[] array) {
        if (array == null || array.length == 0) {
            return;
        }
        for (int i = 1; i < array.length; i++) {
            int target = array[i];          // 获取当前比较目标数值
            int j = i;  // j-1是前一位
            while (j > 0 && target <= array[j - 1]) {   // 比较当前位与前一位的大小，如满足条件，则向后替换，并移动j指针
                array[j] = array[j-1];
                j--;
            }
            array[j] = target;  // 此时的j是j--之后的index，不满足上诉条件时跳出，并插入目标值
        }
        System.out.println(Arrays.toString(array));
    }

#####4.快速排序  递归部分，分区部分，值交换部分三部分组成

    public void quickSort(int[] array) {
        if (array == null || array.length == 0) {
            return;
        }
        Sort(array, 0, array.length - 1);
        System.out.println(Arrays.toString(array));

    }

    public void Sort(int[] array,int left,int right) {
        if (left >= right) {
            return;
        }
        int midPos = partition(array, left, right);
        Sort(array, left, midPos - 1);
        Sort(array, midPos + 1, right);

    }

    int[] array = {3, 2, 5, 1, 7, 6, 4};
    public static int partition(int[] array, int left, int right) {
        int pivotValue = array[left];
        int pivotPointer = left;
        while (left < right) {
            // 分别找出左右半区，小于或则大于基数的值的index
            while (left < right && pivotValue <= array[right]) {
                right--;
            }
            while (left < right && pivotValue >= array[left]) {
                left++;
            }
            // 左右区间变换
            int temp = array[left];
            array[left] = array[right];
            array[right] = temp;
        }
        // 将基数转到中间位置
        int temp = array[pivotPointer];
        array[pivotPointer] = array[left];
        array[left] = temp;

        return left;
    }
#####5.希尔排序——缩减增量排序，与插入排序结合
    public void shellSort(int[] array) {
        if (array.length == 0 || array == null) {
            return;
        }

        int len = array.length / 2;
        while (len > 0) {                               // 基于增量变化循环
            for (int i = len; i < array.length; i++) {  // 插入一个插入排序
                int target = array[i];
                int j = i;
                while (j > 0 && target < array[j - len]) {
                    array[j] = array[j - len];
                    j -= len;
                }
                array[j] = target;
            }
            len = len / 2;
        }
        System.out.println(Arrays.toString(array));
    }

#####6.归并排序采用2-路归并，先两两集合比较在四四比较，最终得到有序数组，进行合并
    public int[] mergeSort(int[] array) {
        if (array.length == 1) {

            return array;
        }
        int mid = array.length / 2;
        int[] leftArr = Arrays.copyOfRange(array, 0, mid);
        int[] rightArr = Arrays.copyOfRange(array, mid, array.length);
        return merge(mergeSort(leftArr), mergeSort(rightArr));
    }

    public int[] merge(int[] leftArr, int[] rightArr) {
        int[] temp = new int[leftArr.length + rightArr.length];

        for (int i = 0, leftIndex = 0, rightIndex = 0; i < temp.length; i++) {
            if (leftIndex >= leftArr.length) {
                temp[i] = rightArr[rightIndex];
                rightIndex++;
            } else if (rightIndex >= rightArr.length) {
                temp[i] = leftArr[leftIndex];
                leftIndex++;
            } else if (leftArr[leftIndex] > rightArr[rightIndex]) {
                temp[i] = rightArr[rightIndex];
                rightIndex++;
            } else {
                temp[i] = leftArr[leftIndex];
                leftIndex++;
            }
        }
        System.out.println(Arrays.toString(temp));
        return temp;
    }

#####7.计数排序 找出最大值最小值以及偏执bias
    public void countSort(int[] array) {
        if (array == null || array.length == 0) {
            return;
        }

        int min = array[0];
        int max = array[0];
        for (int i = 1; i < array.length; i++) {
            if (array[i] < min) {
                min = array[i];
            }
            if (array[i] > max) {
                max = array[i];
            }
        }

        int bias = min; // 设置一个偏移量，用来确定原数组中的数再temp数组中应该对应的索引位置
        int[] temp = new int[max - min + 1];  //作为计数的数组
        Arrays.fill(temp, 0);

        // 遍历整个数组并计算出ints中每个数的个数；注意个数与元素之间的关系
        for (int i = 0; i < array.length; i++) {
            temp[array[i] - bias] += 1;  // 遍历整个数组求出其在temp中对应的位置，存在则+1
        }

        // 输出基于temp中的计数，将其覆盖在原ints数组上
        int indexofarray = 0;
        int indexofTemp = 0;
        while (indexofarray < array.length) {
            // 先判断在计数数组Temp中该元素是否有值，
            if (temp[indexofTemp] != 0) {
                // 如果有值则依次覆盖在ints数组之中， ints中元素的值 都利用temp数组的索引及bias来获取
                array[indexofarray] = indexofTemp + bias;
                temp[indexofTemp] -= 1;
                indexofarray++;
            } else {
                indexofTemp++;
            }
        }
        System.out.println(Arrays.toString(array));

    }

#####8.桶排序 相同长度数据的首位数分桶
    public void bucketSort(int[] array) {
        if (array == null || array.length == 0) {
            return;
        }

        int orignal = array[0];
        int dishu = 10;  // 基于桶排序的数据，判断数据的长度，
        while (orignal / dishu > 10) {
            dishu *= 10;
        }

        // 实际上是个二维数组 （（1），（2），（3），...）  1，2，3分别为子桶      构建10个桶（重点构建复合的数组）
        int bucketSize = 10;
        ArrayList<ArrayList<Integer>> arrayLists = new ArrayList<>(bucketSize);

        // 构建桶 二维
        for (int i = 0; i < bucketSize; i++) {
            arrayLists.add(new ArrayList<Integer>());  // 构建10个桶\
        }

        // 向桶中插入元素
        for (int i = 0; i < array.length; i++) {
            int temp = array[i] / dishu;
            arrayLists.get(temp).add(array[i]); // 分别输出每个桶的元素
        }

        // 为桶中的元素排序
        for (int i = 0; i < arrayLists.size(); i++) {
            if (!arrayLists.get(i).isEmpty()) {
                Collections.sort(arrayLists.get(i));
            }
        }

        // 按序输出
        int newIndex = 0;
        for (ArrayList<Integer> arrayList : arrayLists) {
            for (int ele : arrayList) {
                array[newIndex] = ele;
                newIndex++;
            }
        }
        System.out.println(Arrays.toString(array));

    }


#####9.基数排序
    public int[] basicSort(int[] array) {
        if (array == null || array.length < 2) {
            return array;
        }

        int max = array[0];
        for (int i = 1; i < array.length; i++) {
            max = Math.max(max, array[i]); // 利用math类方法快速获得最大值
        }
        // 计算数据最大值有多少位
        int countBit = 0;
        while (max != 0) {
            max /= 10;
            countBit++;
        }
        int mod = 10, div = 1; // 求解用于判断位数
        ArrayList<ArrayList<Integer>> arrayLists = new ArrayList<ArrayList<Integer>>();

        for (int i = 0; i < 10; i++) {
            arrayLists.add(new ArrayList<Integer>());
        }
        // 按照最高位优先的方式排序
        for (int i = 0; i < countBit; i++, mod *= 10, div *= 10) {
            //先求最低位数是多少 并放入数组
            for (int j = 0; j < array.length; j++) {
                int num = (array[j] % mod) / div;
                arrayLists.get(num).add(array[j]);
            }

            // 放入数组后按照顺序取出放入array数组，并进入下一个循环（第二高位）
            int index = 0;
            for (int j = 0; j < arrayLists.size(); j++) {
                for (int k = 0; k < arrayLists.get(j).size(); k++) {
                    array[index] = arrayLists.get(j).get(k);
                    index++;
                }
                arrayLists.get(j).clear(); // 清空 用于下一次循环
            }
        }
        System.out.println(Arrays.toString(array));
        return array;
    }