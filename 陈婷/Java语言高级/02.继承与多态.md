# 02.继承与多态
## 1. 继承
> 面向对象三大特征：封装性、**继承性**、多态性。
> 继承是多态的前提，如果没有继承就没有多态。

继承主要解决的问题 ：**共性抽取**
* **父类**：也可以叫基类、超类
* **子类**：也可以叫派生类

**继承当中的特点 :**
1. 子类可以拥有父类的“内容”
2. 子类还可以拥有自己的内容

### 继承的格式
在继承关系中，**"子类就是一个父类"**，即子类可以被当做父类看待。

**定义父类格式 ：**(一个普通类定义)
```Java
public class 父类名称{
    // ...
}
```
**定义子类格式 ：**
```Java
public class 子类名称 extends 父类名称{
    // ...
}
```
*举例 ：*
```Java
// 定义一个父类：员工
public class Employee {
    public void method(){
        System.out.println("定义了一个父类");
    }
}
```

```Java
// 定义一个员工的子类：教师
public class Teacher extends Employee{
}
```

```Java
// 定义了员工的另一个子类：助教
public class Assistant extends Employee{
}
```

```Java
public class Demo01Extends{
    public static void main(String[] args) {
        // 创建了一个子类教师的对象
        Teacher teacher = new Teacher();
        // Teacher类当中虽然什么都没写，但是会继承来自父类的method方法。
        teacher.method();

        // 创建了另一个子类助教的对象
        Assistant assistant = new Assistant();
        assistant.method();
    }
}
```

### 继承中成员变量的访问特点
* 在父子类关系中，如果成员变量重名，则创建子类对象时，有两种访问方式：
  * 直接通过对象访问成员变量：**等号左边是谁**，就优先用谁，没有则向上找。
  * 间接通过成员方法访问成员变量：**方法属于谁**，就优先用谁，没有则向上找。
  
*举例 ：*
```Java
// 定义一个父类
public class Fu {
    int numFu = 10;
    int num = 100;
    public void methodFu(){
        // 使用的是本类当中的，不会向下找子类的
        System.out.println(num);
    }
}
```

```Java
// 定义一个子类
public class Zi extends Fu{
    int numZi = 20;
    int num = 200;

    public void methodZi(){
        // 因为本类当中有，则使用本类当中的
        System.out.println(num);
    }
}

```

```Java
public class Demo01ExtendField {
    public static void main(String[] args) {
        Fu fu = new Fu(); // 创建父类对象
        System.out.println(fu.numFu);  // 只能使用父类的东西，没有任何子类内容。

        Zi zi =new Zi();
        System.out.println(zi.numFu);  // 10
        System.out.println(zi.numZi);  // 20

        // 等号左边是谁，就优先用谁
        System.out.println(zi.num); // 优先子类，200

        // 这个方法是子类的，优先用子类的，没有再向上找
        zi.methodZi();  // 200
        // 这个方法是在父类中定义的
        zi.methodFu();  // 100
    }
}
```

* 出现重名
  * 局部变量：直接写成员变量名
  * 本类成员变量：this.成员变量名
  * 父类的成员变量：super.成员变量名
```Java
public class Zi extends Fu {
    int num = 20;

    public void method(){
        int num = 30;
        System.out.println(num); // 30
        System.out.println(this.num);  // 20
        System.out.println(super.num); // 10
    }
}
```

* 在父类的继承关系当中，创建子类对象，访问成员方法的规则：创建的对象是谁，就优先用谁，没有就向上找。
* **注意事项**:无论是成员方法还是成员变量，如果没有则向上找父类，不会向下找子类。

```Java
public class Demo01ExtendsMethod {
    public static void main(String[] args) {
        Zi zi = new Zi();

        zi.methodFu();  // 父类方法执行！ 
        zi.methodZi();  // 子类方法执行！
        
        // 创建的是new了子类对象，所以优先用子类方法
        zi.method();    // 子类重名方法执行！
    }
}
```

* **重写**(Override):在继承关系中，方法的名称一样，参数列表也一样。
  * 重写(Override): 方法的名称一样，参数列表也**一样**。覆盖、复写
  * 重载(Overload): 方法的名称一样，参数列表**不一样**。

**方法覆盖重写的注意事项**：
1. 必须保证父类之间方法的名字相同，参数列表也相同。
  @ Override: 写在方法前面，用来检测是不是有效的正确覆盖重写。
2. 子类方法的返回值必须**小于等于**父类方法的返回值范围。
  提示：java.lang.Object类是所有类的公共最高父类。java.lang.String就是Object的子类。
3. 子类方法的权限必须**大于等于**父类方法的权限修饰符。
  提示：public > protected > (default) > private
  (default)不是关键字default，而是什么都不写，留空。

**对于已经投入使用的类，尽量不要进行修改。推荐定义一个新的类，来重复利用其中的共性内容，并且添加改动新内容——继承。**
*举例 ：*
```Java
// 父类
// 定义一个手机类
public class Phone {
    public void call(){
        System.out.println("打电话");
    }
    public void send(){
        System.out.println("发短信");
    }
    public void show(){
        System.out.println("来电显示");
    }
}
```

```Java
// 子类
// 定义一个新手机，使用老手机作为父类
public class NewPhone extends Phone{

    @Override
    public void show(){
//        System.out.println("显示号码");
        super.show();  // 把父类的show方法拿过来复制利用
        // 自己子类再来添加更多内容
        System.out.println("显示姓名");
        System.out.println("显示头像");
    }
}
```

* **继承关系中，父子类构造方法的访问特点：**
1. 子类构造方法当中有一个默认隐含的“super()”调用，所以一定是先调用父类构造后，执行子类构造。
2. 子类构造可以通过super关键字来调用父类重载构造。
3. super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。
4. 子类必须调用父类构造方法，不写则赠送super(),写了则用写的指定的super调用，super只能有一个，必须是第一个。

* **super关键字的用法：**
  1. 子类的成员方法中，访问父类的成员变量。
  2. 子类的成员方法中，访问父类的成员方法。
  3. 子类的构造方法中，访问父类的构造方法。

> super关键字用来访问父类内容，而this关键字用来访问本类内容。
* **this关键字的用法：**
  1. 在本类的成员方法中，访问本类的成员变量。
  2. 在本类的成员方法中，访问本类的另一个成员方法。
  3. 在本类的构造方法中，访问本类的另一个构造方法。
    在第三种用法当中要注意：
      ① this(...)调用必须是构造方法的第一个语句，唯一一个。
      ② super和this两种构造调用不能同时使用。
*举例 ：*
```Java
public class Zi extends Fu{
    int num = 20;

    public Zi(){
//        super();    // 这一行不再赠送
        this(123);  // 本类的无参构造，调用本类的有参构造
//        this(1,2);  // 错误写法
    }

    public Zi(int n){
        this(1,2);
    }

    public Zi(int n, int m){
        
    }

    public void showNum(){
        int num = 10;
        System.out.println(num);    // 局部变量
        System.out.println(this.num);   // 本类中的成员变量
        System.out.println(super.num);   // 父类中的成员变量
    }
    public void methodA(){
        System.out.println("AAA");
    }
    public void methodB(){
        this.methodA();
        System.out.println("BBB");
    }
}
```

* **Java继承的特征：**
  1. Java语言是**单继承**的。一个类的直接父类只能有唯一一个。
  2. Java语言可以**多级继承**。
  3. 一个子类的直接父类是唯一的，但是一个父类可以拥有多个子类。
```Java
class A{}
class B extends A{} // 正确，单继承
class C extends B{} // 正确，多级继承
class D extends B{} // 正确
class E extends A, C{}  // 错误，不能多继承
```  

## 2. 抽象类
> 抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束。
> 抽象方法：抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可。
```Java 
public abstract  class Animal {
    // 这是一个抽象方法，代表吃东西，但是具体吃什么（大括号的内容）不确定。
    public abstract void eat();
    
    // 这是普通的成员方法
    public void normalMethod(){
        
    }
}
```

* **如何使用抽象类和抽象方法：**
  1. 不能直接创建new抽象类对象。
  2. 必须用一个子类来继承抽象父类。
  3. 子类必须要覆盖重写抽象父类当中所有的抽象方法。
    覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。
  4. 创建子类对象使用。

*举例 ：*
```Java
// 父类
public abstract  class Animal {
    // 这是一个抽象方法，代表吃东西，但是具体吃什么（大括号的内容）不确定。
    public abstract void eat();

//    // 这是普通的成员方法
//    public void normalMethod(){
//
//    }
}

// 子类
public class Cat extends Animal{
    @Override
    public void eat(){
        System.out.println("猫吃鱼");
    }
}

// 主程序
public class DmeoMain {
    public static void main(String[] args) {
//        Animal animal = new Animal();   // 错误写法! 不能直接创建抽象类对象
        Cat cat = new Cat();
        cat.eat();
    }
}
```

**注意事项：**
  1. 抽象类不能创建对象，如果创建，编译无法通过而报错，不能创建其非抽象子类的对象。
  2. 抽象类中可以有构造方法，是供子类创建对象时，初始化父类成员使用的。
  3. 抽象类中不一定包含抽象方法，但是抽象方法的类必须是抽象类。
  4. 抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错，除非该子类也是抽象类。

### 抢红包综合案例
* **发红包**的逻辑，三要素：
  * 返回值类型： ArrayList//<Integer//>
  * 方法名称： send
  * 参数列表：
    * 1.总共发多少钱 int totalMoney
    * 2.分成多少份   int count
* **收红包**的逻辑，三要素：
  * 返回值类型： void
  * 方法名称： receive
  * 参数列表： ArrayList//<Integer//>

*举例 ：*
```Java
// 用户
public class User {
    private String name;    // 姓名
    private int money;  // 余额
    public User(){

    }
    public User(String name,int money){
        this.money = money;
        this.name = name;
    }

    // 显示当前用户有多少钱
    public void show(){
        System.out.println("我叫"+name+",我有余额："+money);
    }

    public String getName() {
        return name;
    }
    public void setName(String name){
        this.name = name;
    }
    public int getMoney(){
        return money;
    }
    public void setMoney(int money){
        this.money = money;
    }

}

// 群主
import java.util.ArrayList;

public class Manager extends User{
    public Manager() {
    }

    public Manager(String name,int money) {
        super(name,money);
    }

    public ArrayList<Integer> send(int totalMoney, int count){
        // 首先需要一个集合，用来存储若干个红包金额
        ArrayList<Integer> redList = new ArrayList<>();
        // 首先看一下群主自己的余额
        int leftMoney = super.getMoney();   // 群主当前余额
        if (leftMoney < totalMoney){
            System.out.println("余额不足");
            return redList;     // 返回空集合
        }

        // 扣钱，其实就是重新设置余额
        super.setMoney(leftMoney - totalMoney);

        // 发红包需要平均拆分成count份
        int avg = totalMoney / count;
        int mod = totalMoney % count;       // 余数

        // 除不开的零头，包在最后一个红包当中
        // 把红包一个一个放到集合当中
        for (int i = 0; i < count - 1; i++) {
            redList.add(avg);
        }

        // 最后一个红包
        int last = avg+mod;
        redList.add(last);
        return redList;
    }

}

// 用户
import java.util.ArrayList;
import java.util.Random;

public class Member extends User{
    public Member() {
    }

    public Member(String name, int money) {
        super(name, money);
    }

    public void receive(ArrayList<Integer> list){
        // 从多个红包当中随便抽取一个，给自己
        // 随机获取一个集合当中的索引编号
        int index = new Random().nextInt(list.size());
        // 根据索引，从集合当中删除，并且达到被删除的红包，给自己
        Integer delta = list.remove(index);
        // 当前成员之间本来有多少钱
        int money = super.getMoney();
        // 加法，并且重新设置回去
        super.setMoney(delta+money);

    }
}

// 主程序
java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        Manager manager = new Manager("群主",100);
        Member one = new Member("成员A",0);
        Member two = new Member("成员B",0);
        Member three = new Member("成员C",0);

        manager.show();
        one.show();
        two.show();
        three.show();
        // 群主总共发20，分成3个红包
        ArrayList<Integer> redList = manager.send(20,3);
        // 三个成员收红包
        one.receive(redList);
        two.receive(redList);
        three.receive(redList);
        System.out.println("=========================");

        manager.show(); // 20
        three.show();
        one.show();
        two.show();
```

## 3. 接口
> 接口就是多个类的**公共规范标准**。
> 接口就是一种引用数据类型，最重要的内容就是其中的：**抽象方法**。

**定义一个接口的格式**：
```Java
public interface 接口名称 {
  // 接口内容
}
```
**备注** : 换成了关键字interface之后，编译生成的字节码文件仍然是：.java -> .class
  * 若为Java 7，那么接口中可以包含的内容有：
    * 1、常量
    * 2、抽象方法
  * 若为Java 8，还可以额外包含：
    * 3、默认方法
    * 4、静态方法
  * 若为Java 9，还可以额外包含：
    * 5、私有方法
* 在任何版本的Java中，接口都能定义抽象方法。
  * 格式： public abstract 返回值类型 方法名称(参数列表);

**注意事项** ：
  1. 接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract。
  2. 这两个关键字修饰符，可以选择性地省略。
  3. 方法的三要素可以随意定义。
  ```Java
  public interface MyInterfaceAbstract {
    // 以下都是抽象方法
    public abstract void methodAbs1();    
    abstract void methodAbs2();
    public void methodAbs3();
    void methodAbs4();
}
  ```

**接口的使用步骤** ：
  1. 接口**不能直接使用**，必须有一个“实现类”来实现该接口。
  ```Java
  public class 实现类名称 implements 接口名称{
      // ...
  }
  ```
  2. 接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。
    实现： 去掉abstract关键字，加上方法体大括号。
  3. 创建实现类的对象，进行使用。
  **注意事项：如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己必须是抽象类。**
  
```Java
// 接口
public interface MyInterfaceAbstract {
    // 以下都是抽象方法
    public abstract void methodAbs1();
    abstract void methodAbs2();
    public void methodAbs3();
    void methodAbs4();
}


// 接口的实现类
public class MyInterfaceAbstractImpl implements MyInterfaceAbstract{
    @Override
    public void methodAbs1() {
        System.out.println("这是第一个方法");
    }

    @Override
    public void methodAbs2() {
        System.out.println("这是第二个方法");
    }

    @Override
    public void methodAbs3() {
        System.out.println("这是第三个方法");
    }

    @Override
    public void methodAbs4() {
        System.out.println("这是第四个方法");
    }
}

// 使用接口
public class Demo01Interface {
    public static void main(String[] args) {
        // 不能直接 new 接口对象使用
//        MyInterfaceAbstract inter = new MyInterfaceAbstract();

        // 创建实现类的对象使用
        MyInterfaceAbstractImpl impl = new MyInterfaceAbstractImpl();
        impl.methodAbs1();
        impl.methodAbs2();
    }
```
* **从Java 8开始，接口当中允许定义默认方法。**
```Java
public default 返回值类型 方法名称(参数列表){
    // 方法体
}
```
**备注**：接口当中的默认方法可以解决接口升级的问题。
  1. 接口的默认方法，可以通过接口实现类对象，直接调用。
  2. 接口的默认方法，也可以被接口实现类进行覆盖重写。

```Java
public interface MyInterFaceDefault {
    // 抽象方法
    public abstract void methodAbs();
    // 新添加了一个抽象方法
//    public abstract void methodAbs2();
    // 新添加的方法，改成默认方法
    public default void methodDefault(){
        System.out.println("这是新添加的默认方法");
    }
}

public class MyInterfaceDefaultA implements MyInterFaceDefault{
    @Override
    public void methodAbs() {
        System.out.println("实现了抽象方法：AAA");
    }
}

public class MyInterfaceDefaultB implements MyInterFaceDefault{
    @Override
    public void methodAbs() {
        System.out.println("实现了抽象方法：BBB");
    }

    @Override
    public void methodDefault(){
        System.out.println("实现类B覆盖重写了接口的默认方法！");
    }
}

public class Demo02Interface {
    public static void main(String[] args) {
        MyInterfaceDefaultA a = new MyInterfaceDefaultA();
        a.methodAbs();  // 调用抽象方法，实际运行的是右侧实现类。

        // 调用默认方法，如果实现类没有，就默认向上找接口
        a.methodDefault();  // 这是新添加的默认方法

        MyInterfaceDefaultB b = new MyInterfaceDefaultB();
        b.methodAbs();
        b.methodDefault();  // 实现类B覆盖重写了接口的默认方法
    }
}

/*
实现了抽象方法：AAA
这是新添加的默认方法
实现了抽象方法：BBB
实现类B覆盖重写了接口的默认方法！
*/
```
* **从Java 8开始，接口当中允许定义静态方法。**
```Java
public static 返回值类型 方法名称(参数列表){
    // 方法体
} 
// 就是将abstract或者default换成static即可，带上方法体。
```
**注意事项**：不能通过接口实现类的对象来调用接口当中的静态方法。
**正确用法**：通过接口名称，直接调用其中的静态方法。
  ```Java
  接口名称.静态方法名(参数);
  ```
*静态和对象没有关系，静态只和类有关系。*
```Java
// 接口 ：
public interface MyInterfaceStatic {
    public static void methodStatic(){
        System.out.println("这是接口的静态方法");
    }
}
// 实现类 ：
public class MyinterfaceStaticImpl implements MyInterfaceStatic {

}
// 主方法 ：
public class Demo03Interface {
    public static void main(String[] args) {
        // 创建实现类对象
        MyinterfaceStaticImpl impl = new MyinterfaceStaticImpl();

        // 错误写法
//        impl.methodStatic();

        // 直接通过接口名称调用静态方法
        MyInterfaceStatic.methodStatic();
    }
}
```

* **从Java9开始，接口当中允许定义私有方法。**
  1. 普通私有方法，解决多个默认方法之间代码重复问题
  ```Java
  private 返回值类型 方法名称(参数列表){
    // 方法体
  }
  ```
  2. 静态私有方法，解决多个静态方法之间代码重复的问题
  ```Java
  private static 返回值类型 方法名称(参数列表){
    // 方法体
  }
  ```  
* **接口当中也可以定义“成员变量”，但是必须使用public static final 三个关键字进行修饰。** 从效果上看，这其实就是接口的**常量**。
  ```Java
  public static final 数据类型 常量名称 = 数据值;
  ```
  **备注** ：一旦使用final关键字修饰，说明不可变。
  **注意事项** :
  1. 接口当中的常量，可以省略public static final。（不写也照样是这样）。
  2. 接口当中的常量，必须进行赋值；不能不赋值。
  3. 接口中常量的名称，使用完全大写的字母，用下划线进行分隔。（推荐命名规则）
```Java
public interface MyInterfaceConst {
    // 这其实就是一个常量，一旦赋值，不可以修改。
    public static final int NUM_OF_MY_CLASS = 10;
}

public class Demo05Interface {
    public static void main(String[] args) {
        // 访问接口当中的常量
        System.out.println(MyInterfaceConst.NUM_OF_MY_CLASS);
    }
}
```

### 接口的内容小结
**在Java 9+ 版本中，接口的内容有：**
1. 成员变量其实就是常量，格式：
  ```Java
  [public] [static] [final] 数据类型 常量名称 = 数据值;
  ```
  
  **注意** ：
  * 常量必须进行赋值，而且一旦赋值就不能改变。
  * 常量名称完全大写，用下划线进行分隔。
---
2. 接口中最重要的就是抽象方法，格式：
  ```Java
  [public] [abstract] 返回值类型 方法名称(参数列表);
  ```
  **注意** ：实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类。

---
3. 从 Java 8 开始，接口里允许定义默认方法，格式：
  ```Java
  [public] default 返回值类型 方法名称(参数列表){方法体}
  ```
  **注意** ：默认方法也可以被覆盖重写。
  
  ---
4. 从 Java 8 开始，接口里允许定义静态方法，格式
  ```Java
  [public] static 返回值类型 方法名称(参数列表){方法体}
  ```
  **注意** ：应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法。
  
  ---
5. 从 Java 9 开始，接口里允许定义私有方法，格式：
```Java
// 普通私有方法
private 返回值类型 方法名称(参数列表){方法体}
// 静态私有方法
private static 返回值类型 方法名称(参数列表){方法体}
```

**注意** ：private的方法只有接口自己才能调用，不能被实现类或别人使用。

---
### 使用接口的注意事项
1. 接口是没有静态代码块或者构造方法的。
  ```Java
  public interface MyInterface {
    // 错误写法，接口不能有静态代码块
//    static {
//        
//    }
    // 错误写法，接口不能有构造方法
//    public MyInterface();
}
  ```
2. 一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。
  ```Java
  public class MyInterfaceImpl implements MyInterfaceA, MyInterfaceB{
      // 覆盖重写所以抽象方法
  }
  ```
  
```Java
public class MyInterfaceImpl /*extends Object*/ implements MyInterfaceA,MyInterfaceB {
    @Override
    public void methodA() {
        System.out.println("覆盖重写了A方法！");
    }

    @Override
    public void methodB() {
        System.out.println("覆盖重写了B方法！");
    }
}
```

3. 如果实现类没有覆盖重写所以接口当中的所有抽象方法，那么实现类就必须是一个抽象类。
```Java
public abstract class MyInterfaceAbstract implements MyInterfaceA, MyInterfaceB {
    @Override
    public void methodA() {

    }

    @Override
    public void methodAbs() {

    }
}
```

4. 如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次。
5. 如果实现类实现的多个接口中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。

```Java
public class MyInterfaceImpl /*extends Object*/ implements MyInterfaceA,MyInterfaceB {
    @Override
    public void methodA() {
        System.out.println("覆盖重写了A方法！");
    }

    @Override
    public void methodB() {
        System.out.println("覆盖重写了B方法！");
    }

    @Override
    public void methodAbs() {
        System.out.println("覆盖重写了AB接口都有的抽象方法");
    }

    @Override
    public void methodDefault() {
        System.out.println("对多个接口当中默认方式进行覆盖重写");
    }
}
```
6. 一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用**父类**当中的方法。
```Java
public class Fu {
    public void method(){
        System.out.println("父类方法");
    }
}
public interface MyInterface {
    public default void method(){
        System.out.println("接口的默认方法");
    }
}
public class Zi extends Fu implements MyInterface{
}
```
```Java
public class Demo01Interface {
    public static void main(String[] args) {
        Zi zi = new Zi();
        zi.method();    // 父类方法
    }
}
```

* **类与接口的关系**
1. 类与类之间是单继承的，直接父类只有一个。
2. 类与接口之间是多实现的，一个类可以实现多个接口。
3. 接口与接口之间是多继承的。
**注意**：
    1. 多个父接口当中的抽象方法如果重复，没关系。
    2. 多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，**且带着default关键字**。

```Java
public interface MyInterFaceA {
    public abstract void methodA();
    public abstract  void methodCommon();
    public default void methodDefault(){
        System.out.println("AAA");
    }
}
public interface MyInterFaceB {
    public abstract void methodB();
    public abstract  void methodCommon();
    public default void methodDefault(){
        System.out.println("BBB");
    }
}
/*
这个子接口当中有几个方法？ 4个。
methodA 来源于接口A
methodB 来源于接口B
methodCommon 来源于接口AB
method 来源于接口本身
*/
public interface MyInterface extends MyInterFaceA,MyInterFaceB {

    public abstract void method();

    @Override
    default void methodDefault() {

    }
}
public class MyInterfaceImpl implements MyInterface {
    @Override
    public void method() {

    }

    @Override
    public void methodA() {

    }

    @Override
    public void methodB() {

    }

    @Override
    public void methodCommon() {

    }
}
```


## 4. 多态
> 面向对象的三大特征：封装性、继承性、**多态性**。
> extends 继承或者 implements 实现，是多态性的前提。

* 代码中体现多态：**父类引用指向子类对象**。格式：
  ```Java
  父类名称 对象名 = new 子类名称();
  或
  接口名称 对象名 = new 实现类名称();
  ```

```Java
public class Fu {
    public void method(){
        System.out.println("父类方法");
    }
    public void methodFu(){
        System.out.println("父类特有的方法");
    }
}
public class Zi extends Fu{
    @Override
    public void method(){
        System.out.println("子类方法");
    }
}
public class Demo01Polymorphism {
    public static void main(String[] args) {
        // 多态的写法
        // 左侧父类的引用指向右侧子类的对象
        Fu obj = new Zi();
        obj.method();   // 子类方法
        obj.methodFu(); // 父类特有方法
    }
}
```

* 访问成员变量的两种方式：
  1. 直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找
  2. 间接通过成员方法访问成员变量：看该方法属于谁则优先用谁，没有则向上找


```Java
public class Fu {
    int num = 10;
    public void showNum(){
        System.out.println(num);
    }
}
public class Zi extends Fu{
    int num = 20;
    int age = 16;
    @Override
    public void showNum(){
        System.out.println(num);
    }
}
public class Demo01MultiField {
    public static void main(String[] args) {
        // 使用多态的写法，父类引用指向子类对象
        Fu obj = new Zi();
        System.out.println(obj.num);    // 10,成员变量不能进行覆盖重写
//        System.out.println(obj.age);  // 错误写法！
        System.out.println("========================");

        // 子类没有覆盖重写，就是父: 10
        // 子类如果覆盖重写，就是子: 20
        obj.showNum();

    }
}
```

* 在多态的代码中，成员方法的访问规则:
  * 看 new 的是谁，就优先用谁，没有则向上找。
  * 口诀：编译看左边，运行看右边。
  * 对比：
    * 成员变量：编译看左边，运行还看左边
    * 成员方法：编译看左边，运行看右边
* **多态的好处** ：无论右边 new 的时候换成哪个子类对象，等号左边调用方法都不会变。


* **对象的转型**
  1. 对象的**向上**转型：其实就是多态的写法。格式：
    ```Java
    父类名称 对象名 = new 子类名称();
    eg: Animal animal = new Cat(); // 本来是猫，向上转型为动物。 
    // 类似于： double num = 100; // 正确，int->double，自动类型转换。
    ```
    含义：右侧创建一个子类对象，把它当做父类来看待使用。（把猫当成动物）
    **注意 ：** 向上转型一定是安全的，从小范围转向大范围。弊端：一旦向上转型为父类，那么就无法调用子类的特有方法。
    
  2. 对象的**向下**转型： 其实就是一个**还原**的动作。格式：
    ```Java
    子类名称 对象名 = (子类名称)父类对象;
    eg: Cat cat = (Cat) animal; // 本来是猫，已经当做动物了，还原回来成为本来的猫。
    /* 类似于： int num = (int)10.0;  // 可以
               int num = (int)10.5;  // 不可以，精度损失
    */
    ```
    含义：将父类对象，**还原**成为本来的子类对象。
    **注意：** a. 必须保证对象本来创建的时候，就是猫，才能向下转型成为猫；b. 如果创建的时候本来就不是猫，非要转型为猫会报错。
    
* 如何知道一个父类引用的对象，本来的子类是什么？格式：
  ```Java
  /// 向下转型需要进行类型检查
  对象 instanceof 类名称;
  ```
  * 将会得到一个boolean值结果，判断前面的对象能否当做后面的类实例。
```Java
public class Demo02Instansof {
    public static void main(String[] args) {
        Animal animal =new Cat();   // 本来是一只猫
        animal.eat();   // 猫吃鱼

        // 如果希望调用类特有方法，需要向下转型
        // 判断一下父类引用animal是不是Dog
        if(animal instanceof Dog){
            Dog dog = (Dog) animal;
            dog.watchHouse();
        }
        // 判断一下animal本来是不是Cat
        if (animal instanceof Cat){
            Cat cat = (Cat) animal;
            cat.catchMouse();
        }
        giveMeAPet(new Dog());
    }
    public static void giveMeAPet(Animal animal){
        if(animal instanceof Dog){
            Dog dog = (Dog) animal;
            dog.watchHouse();
        }
        // 判断一下animal本来是不是Cat
        if (animal instanceof Cat){
            Cat cat = (Cat) animal;
            cat.catchMouse();
        }
    }
}
```

### 笔记本电脑综合案例
```Java
public interface USB {
    public abstract void open();    // 打开设备

    public abstract void close();   // 关闭设备

}
public class Computer {
    public void powerOn(){
        System.out.println("笔记本电脑开机");
    }

    public void powerOff(){
        System.out.println("笔记本电脑关机");
    }

    // 使用USB设备的方法，使用接口作为方法的参数
    public void useDevice(USB usb){
        usb.open(); // 打开设备
        if(usb instanceof Mouse){
            Mouse mouse = (Mouse)usb;   // 向下转型
            mouse.click();
        }
        if(usb instanceof Keyboard){
            Keyboard keyboard = (Keyboard)usb;  // 向下转型
            keyboard.type();
        }
        usb.close();    // 关闭设备
    }
}
// 键盘就是一种 USB
public class Keyboard implements USB {
    @Override
    public void open() {
        System.out.println("打开键盘");
    }

    @Override
    public void close() {
        System.out.println("关闭键盘");
    }

    public void type(){
        System.out.println("键盘输入");
    }
}
// 鼠标就是一种 USB
public class Mouse implements USB {
    @Override
    public void open() {
        System.out.println("打开鼠标");
    }

    @Override
    public void close() {
        System.out.println("关闭鼠标");
    }
    public void click(){
        System.out.println("点击鼠标");
    }
}
public class DemoMain {
    public static void main(String[] args) {
        // 首先创建一个电脑
        Computer computer = new Computer();
        computer.powerOff();

        // 准备一个鼠标，供电脑使用
//        Mouse mouse = new Mouse();
        // 首先进行向上转型
        USB usbMouse = new Mouse(); // 多态写法
        // 参数是USB类型
        computer.useDevice(usbMouse);

        //创建一个USB键盘
        Keyboard keyboard = new Keyboard(); // 没有使用多态的写法
        // 方法参数是USB类型，方法传递的是实现类对象
        computer.useDevice(keyboard);   // 正确写法！发生了向上转型
        // 使用子类对象，匿名对象，也可以
        computer.useDevice(new Keyboard()); // 也是正确写法，

        computer.powerOff();
        System.out.println("====================");
        method(10.0);   // 正确写法：double->double
        method(10); // 也是正确写法：int->double
        int a = 30;
        method(a);
    }

    public static void method(double num){
        System.out.println(num);
    }
}
```


## 5. final关键字
> final 关键字代表最终，不可改变的。

* 常用的四种用法：
  1. 可以用来修饰一个类
  2. 可以用来修饰一个方法
  3. 还可以用来修饰一个局部变量
  4. 还可以用来修饰一个成员变量

* 当final关键字用来修饰一个类的时候，格式：
  ```Java
  public final class 类名称{
    // ...
  }
  ```
  
  含义： 这个类不能有任何的子类
  **注意：** 一个类如果是final,那么其中所有成员变量都无法进行覆盖重写。（因为没有子类）
  
```Java
// 不能使用一个final类来作为父类
public class MySubClass /*extends MyClass*/ {
}
```

* 当final关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能覆盖重写。格式：
  ```Java
  修饰符 final 返回值类型 方法名称(参数列表){
    // 方法体
  }
  ```
  **注意：** 对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾。
```Java
public abstract class Fu {
    public final void method(){
        System.out.println("父类方法执行！");
    }
    public abstract /*final */void methodAbs();
}

public class Zi extends Fu{
    @Override
    public void methodAbs() {

    }
}
```
  
* final修饰局部变量：只要保证唯一一次赋值即可
  * 对于基本类来说，不可变说的是变量当中的**数据**不可改变。
  * 对于引用数据类型来说，不可变说的是变量当中的**地址值**不可改变。
```Java
public class Demo01Final {
    public static void main(String[] args) {
        int num1 = 10;
        System.out.println(num1);   // 10
        num1 = 20;
        System.out.println(num1);   // 20

        // 一旦使用final用来修饰局部变量，那么这个变量就不能进行更改
        // "一次赋值，终生不变"
        final int num2 = 200;
        System.out.println(num2);   // 200

//        num2 = 250; // 错误写法！不能改变！
//        num2 = 200; // 错误写法！

        // 正确写法！只要保证有唯一一次赋值即可
        final int num3;
        num3 = 30;

        // 对于基本类型来说，不可变说的是变量当中的数据不可改变
        // 对于引用类型来说，不可变指的是变量当中的地址值不可改变
        Student stu1 = new Student("赵五");
        System.out.println(stu1);
        System.out.println(stu1.getName()); // 赵五
        stu1 = new Student("王二");
        System.out.println(stu1);
        System.out.println(stu1.getName()); // 王二
        System.out.println("=========================");

        final Student stu2 = new Student("张三");
//        stu2 = new Student("；李四");  // 错误写法！final的引用类型变量，其中的地址不可改变
        stu2.setName("李四");  
        System.out.println(stu2.getName()); // 李四
    }
}
```

* 对于成员变量来说，如果使用final关键字修饰，那么这个变量也是照样不可变。
  1. 由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值了。
  2. 由于final的成员变量，要么使用直接赋值，要么通过构造方法赋值，二者选其一。
  3. 必须保证类当中所有重载的构造方法，都最终重对final的成员进行赋值。
```Java
public class Person {
    private final String name/* = "张三"*/;

    public Person() {
        name = "李四";
    }
    public Person(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
//    public void setName(String name) {
//        this.name = name;
//    }
}
```


## 6. 权限修饰符
* **Java中有四种权限修饰符：**
  |-|public >|protected >|(default) >|private|
  |-|-|-|-|-|
  |同一个类(自己)|√|√|√|√|
  |同一个包(邻居)|√|√|√|×|
  |不同包子类(儿子)|√|√|×|×|
  |不同包非子类(陌生人)|√|×|×|×|



## 7. 内部类
> 如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类。
* 分类： 
  1. 成员内部类
  2. 局部内部类（包含匿名内部类）
* 成员内部类的定义格式 ：
  ```Java
  修饰符 class 外部类名称{
      修饰符 class 内部类名称{
          // ...
      }
      // ...
  }
  ```
  **注意：** 内用外，随意；外用内，需要内部类对象。
  
* 使用成员内部类的两种方式：
  1. 间接方式： 在外部类的方法当中，使用内部类；然后 main 只是调用外部类的方法。
  2. 直接方式： 
    ```Java
    类对象.对象名 = new 类名称();
    外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();
    // 如果出现了重名，则格式为：
    外部类名称.this.外部类成员变量名    
    ```
```Java
public class Body { // 外部类
    public class Heart{ // 成员内部类
        // 内部类的方法
        public void beat(){
            System.out.println("心脏跳动");
            System.out.println("我叫：" + name);   // 正确写法！
        }
    }

    // 外部类的成员变量
    private String name;

    // 外部类的方法
    public void methodBody(){
        System.out.println("外部类的方法");
       /* Heart heart = new Heart();
        heart.beat();*/
        new Heart().beat();
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

public class Demo01InnerClass {
    public static void main(String[] args) {
        Body body = new Body(); // 外部类对象
        // 通过外部类对象，调用外部类的方法，里面间接在使用内部类Heart
        body.methodBody();
        System.out.println("==============");

        // 按照公式写
        Body.Heart heart = new Body().new Heart();
        heart.beat();
    }
}
```

```Java
// 如果出现了重名现象，那么格式是：外部类名称.this.外部类成员变量名
public class Outer {

    int num = 10;   // 外部类的成员变量

    public class Inner /*extends Object*/{
        int num = 20;   // 内部类的成员变量

        public void methodInner(){
            int num = 30;   // 内部类方法的局部变量
            System.out.println(num);    // 局部变量，就近原则
            System.out.println(this.num);   // 内部类的成员变量
            System.out.println(Outer.this.num);  // 外部类的成员变量
        }

    }
}

public class Demo02InnerClass {
    public static void main(String[] args) {
        // 外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();
        Outer.Inner obj = new Outer().new Inner();
        obj.methodInner();
    }
}
```

* 如果一个类是定义在一个方法内部的，那么这就是一个局部内部类。
  “局部”： *只有当前所属的方法才能使用它* ，出了这个方法外面就不能用了。定义格式：
    ```Java
    修饰符 class 外部类名称{
        修饰符 返回值类型 外部类方法名称(参数列表){
            class 局部内部类名称{
                // ...
            }
        }
    }
    ```
```Java
public class Outer {
    public void methodOuter(){
        class Inner {   // 局部内部类
            int num = 10;
            public void methodInner(){
                System.out.println(num);    // 10
            }
        }
        Inner inner = new Inner();
        inner.methodInner();
    }
}

public class DemoMain {
    public static void main(String[] args) {
        Outer obj = new Outer();
        obj.methodOuter();
    }
}
```



* **小结一下类的权限修饰符：**
  * public > protected > (default) > private
  * 定义一个类的时候，权限修饰符规则：
    1. 外部类：public / (default)
    2. 成员内部类：public / protected / (default) / private
    3. 局部内部类：什么都不写。

* 局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是**有效final的**。
```Java
public class MyOuter {
    public void methodOuter(){
        /*final */int num = 10; // 所在方法的局部变量
//        num = 20;
        class MyInner{
            public void methodInner(){
                System.out.println(num);
            }
        }
    }
}
```
* **注意：** 从 Java 8开始，只要局部变量事实不变，那么final关键字可以省略。原因：
  1. new 出来的对象在堆内存当中。
  2. 局部变量是跟着方法走的，在栈内存当中。
  3. 方法运行结束后，立刻出栈，局部变量就会立刻消失。
  4. 但是 new 出来的对象会在堆当中持续存在，直到垃圾回消失。

* 如果接口的实现类（或者是父类的子类）只需要使用唯一的一次，那么这种情况下可以省略掉该类的定义，而改为使用**匿名内部类**。匿名内部类的定义格式：
  ```Java
  接口名称 对象名 = new 接口名称(){
      // 覆盖重写所有抽象方法
  }
  ```

```Java
public class DemoMain {
    public static void main(String[] args) {
//        MyInterface obj = new MyInterfaceImpl();
//        obj.method();

//        MyInterface some = new MyInterface();   // 错误写法
        MyInterface obj = new MyInterface() {
            @Override
            public void method() {
                System.out.println("匿名内部类实现了方法！");
            }
        };
        obj.method();   // 匿名内部类实现了方法！
    }
}
```
   
* 对格式“ new 接口名称(){...}” 进行解析：
  1. new 代表创建对象的动作。
  2. 接口名称就是匿名内部类需要实现哪个接口。
  3. {...} 这才是匿名内部类的内容
  **注意：** 
      1. 匿名内部类，在**创建对象**的时候，只能使用唯 一 一次。
      如果希望多次创建对象，而且类的内容一样的话，那么就必须使用单独定义的实现类了。
      2. 匿名对象在**调用方法**的时候，只能调用唯 一 一次
      如果希望同一个对象，调用多次方法，那么必须给对象起个名字。
      3. 匿名内部类是省略**实现类/子类名称**，但是匿名对象是省略了**对象名称**。
      强调：匿名内部类和匿名对象不是一回事！

